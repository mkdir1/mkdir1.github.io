<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-17T00:32:17+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[记一次网络问题]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/17/ji-%5B%3F%5D-ci-wang-luo-wen-ti/"/>
    <updated>2014-07-17T00:12:42+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/17/ji-[?]-ci-wang-luo-wen-ti</id>
    <content type="html"><![CDATA[<h4>记一次网络问题及处理</h4>

<h5>问题描述</h5>

<p>周五的时候，网络还很好的，不论是外网还是内网，速度都正常．到周一的时候，速度特别慢，外网更慢．</p>

<p>速度慢，有的网站很快就刷出来，比如百度，so.com特，外网就很慢．qq聊天一切正常．内网中，局域网没问题，可以ping通网关和内网主机，并且ttl时间也很正常，没有延迟的现象</p>

<p>所有网站都可以访问，只是表现为速度慢，要加载很长时间</p>

<!--more-->


<h5>猜测原因</h5>

<p>由于近来，外网好多网站被封，所以外网访问慢的现象暂时没有考虑在内，倒是其它中平时常用的网站确实不能容忍．</p>

<p>咨询过网管，他们也在查找原因．可以确定，他们没改任何配置和参数，近来也没有增添任何新设备过改动</p>

<p>猜测原因：
&ndash; 1.外网的问题．这个排除，因为其它本地方，没有网络问题的报告
&ndash; 2.内部有主机干扰主干路由器，中病毒或者其它．这个可能性也不大，如果是干扰路由器，那样网管会很快查找出原因．也不可能会访问得到网络
&ndash; 3.路由器可能运行异常．网管尝试过重启路由器，但问题仍在
&ndash; 4.线路断了．</p>

<hr />

<h5>问题解决</h5>

<p>其实这个问题应该很明显了，就是第四个原因．但当时很傻的认为，既然可以访问网络，只是速度慢了，所以线路，比如网线／电缆／光纤什么的，一定是通畅无误的，否则不是慢的问题，而是能不能上网的问题．但岂知，问题就出现在此</p>

<p>最后问题确定出现在核心交换机的六对光纤中的一对出了问题造成的，通过问题光纤的数据包会丢失，导致出现选择性的丢包现象.当时为什么没想到，是线路部分断了，这样就会丢包，于是会不停的确认和连接，这样又出现在主干网路中，当大家访问多了，这种现象就更严重了．</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/16/git/"/>
    <updated>2014-07-16T19:27:13+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/16/git</id>
    <content type="html"><![CDATA[<h4>Git常用命令</h4>

<p>Git命令很多，大多都可直接用git查询，有些用不上．常用的也就那几条，记录之．</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git diff/git diff --cached/git diff HEAD
</span><span class='line'>git add -u 将本地改动的文件add
</span><span class='line'>git add -A
</span><span class='line'>git mv file1 file2
</span><span class='line'>git add .
</span><span class='line'>git commit -m'a'
</span><span class='line'>git push origin source
</span><span class='line'>git reset --hard HEAD^/HEAD^^/HEAD~100
</span><span class='line'>git reset -hard ****
</span><span class='line'>git log / git log --pretty=oneline
</span><span class='line'>git reflog 
</span><span class='line'>git status
</span><span class='line'>
</span><span class='line'>working directory工作区---&gt;版本库repository{stage/index暂存区, master};
</span><span class='line'>
</span><span class='line'>git checkout --　file 丢弃工作区的修改，回到和暂存区一致
</span><span class='line'>git reset　HEAD filename撤销暂存区中的修改，表示filename是最新的版本
</span><span class='line'>误删rm文件后，可以git checkout -- file
</span><span class='line'>git rm file从版本库中删除，再git commit -m''或者rm file后再git rm file 再git commit -m''
</span><span class='line'>
</span><span class='line'>本地仓库添加远程库git remote add origin url 远程库名叫origin
</span><span class='line'>git push -u origin master(第一次推送)
</span><span class='line'>git push orighin master
</span><span class='line'>
</span><span class='line'>主分支master，提倡用分支来完成工作，再合并后删除
</span><span class='line'>创建分支git checkout -b dev(b表示创建并切换)相当于git branch dev 和git checkout dev
</span><span class='line'>git branch查看当前分支
</span><span class='line'>git checkout master切回分支
</span><span class='line'>git merge dev合并分支到master上
</span><span class='line'>git branch -d dev 删除分支
</span><span class='line'>
</span><span class='line'>git merge --no-ff -m"" dev合并分支时禁用fast forward方式，这样分支的commit信息还会存在
</span><span class='line'>
</span><span class='line'>git stash把当前工作现场储存起来
</span><span class='line'>git stash list查看工作现场
</span><span class='line'>git stash apply恢复，但stash内容不删除，需要git stash drop删除
</span><span class='line'>git stash pop恢复并删除stash
</span><span class='line'>git remote　－v 查看远程信息
</span><span class='line'>git branch -D branchname强行删除分支
</span><span class='line'>git push origin master推送分支master到远程
</span><span class='line'>git pull把远程的提交抓下来，然后本地合并，解决冲突后再推送上去
</span><span class='line'>一般分支master, dev, bug, featurejjj
</span><span class='line'>git checkout -b dev origin/dev本地创建dev分支
</span><span class='line'>git tag v1.0打标签
</span><span class='line'>git tag查看tags
</span><span class='line'>git tag name commitid -m'a'
</span><span class='line'>git tag -d name 删除
</span><span class='line'>git push origin name 推送某个
</span><span class='line'>git psuh origin --tags推送所有
</span><span class='line'>
</span><span class='line'>github上的pull　request申请后才可以pull上去
</span><span class='line'>fork也可以pull
</span><span class='line'>创建.gitignore文件，把要忽略的文件名放进去git会忽略
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exponentiation]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/16/exponentiation/"/>
    <updated>2014-07-16T10:49:34+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/16/exponentiation</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程之美|数字之迷]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/16/bian-cheng-zhi-mei-%7Cshu-zi-zhi-mi/"/>
    <updated>2014-07-16T10:30:05+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/16/bian-cheng-zhi-mei-|shu-zi-zhi-mi</id>
    <content type="html"><![CDATA[<h4>编程之美之数学之迷</h4>

<p>此书趣味多多．前者类似题充斥网络，始作者即此书也．可见其影响之广，流传之远．细看年月，已数年之久，可谓经典．求职者奉为圭臬，学生党视若珍宝，今一睹真容．</p>

<!--more-->


<p><strong>目录：</strong>
&ndash;  <a href="#1">2.1 二进制中1的个数</a>
&ndash;  <a href="#2">2.2 阶乘</a>
&ndash;  <a href="#3">2.3 发帖水王</a>
&ndash;  <a href="#4">2.4 1的数目</a>
&ndash;  <a href="#5">2.5 最大的k个数目</a>
&ndash;  <a href="#6">2.6 精确表达浮点数</a>
&ndash;  <a href="#7">2.7 最大公约数</a>
&ndash;  <a href="#8">2.8 符合条件的整数</a></p>

<h5 id="1">2.1二进制中1的个数</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google_c++编程规范图]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/15/google-c-plus-plus-bian-cheng-gui-fan-tu/"/>
    <updated>2014-07-15T02:30:11+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/15/google-c-plus-plus-bian-cheng-gui-fan-tu</id>
    <content type="html"><![CDATA[<h5>Google C++ Style Guide</h5>

<p>觅得神图一张，尽解Google C++ Style Guide</p>

<p>制作精美，详尽得当，不可多得</p>

<p>感谢原作者<a href="http://blog.csdn.net/voidccc/article/details/37599203">voidccc</a></p>

<!--more-->


<p><strong>原图（可另存）</strong></p>

<p><img src="http://mkdir1.github.io/images/google_c++.png"></p>

<h5>总结一下</h5>

<ul>
<li><ol>
<li>文件名小写，可有下划线或短线，扩展为.cc</li>
</ol>
</li>
<li><ol>
<li>开关加版权，许可证，作者，说明．．</li>
</ol>
</li>
<li><ol>
<li>.h文件顺序：本类的.h，C系统文件，C++系统文件，其它库，本项目头文件，避免用../.开关，要绝对路径指示.h</li>
</ol>
</li>
<li><ol>
<li>禁止使用using namespace xx,而用using std::string</li>
</ol>
</li>
</ul>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome快捷键]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/15/chromekuai-jie-jian/"/>
    <updated>2014-07-15T00:39:34+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/15/chromekuai-jie-jian</id>
    <content type="html"><![CDATA[<h4>chrome下的快捷键&amp;Vimium</h4>

<p>chrome算是自己常用的浏览器之一吧，一直是键盘党，就算是chrome仍用vimium这种vim插件．对于程序员来说，用鼠标是可耻的，不到万不得已，也不能用．</p>

<p>所以烂熟快捷键可谓高手之于心法，工欲善其事，必先利其器，信然～</p>

<!--more-->


<h5>快捷键大全</h5>

<p>下者所列乃大部常用操作，</p>

<p><strong>常用特注之</strong></p>

<p><strong>Chrome窗口和标签页快捷键</strong></p>

<ul>
<li><strong>Ctrl+N</strong> 打开新窗口</li>
<li><strong>Ctrl+T</strong> 打开新标签页</li>
<li>Ctrl+Shift+N 在隐身模式下打开新窗口</li>
<li>Ctrl+O，选择文件 在谷歌浏览器中打开计算机上的文件</li>
<li>按住 Ctrl 键，然后点击链接 从后台在新标签页中打开链接，但您仍停留在当前标签页中</li>
<li>按住 Ctrl+Shift 键，然后点击链接 在新标签页中打开链接，同时切换到新打开的标签页</li>
<li>按住 Shift 键，然后点击链接 在新窗口中打开链接</li>
<li><strong>Alt+F4</strong> 关闭当前窗口</li>
<li><strong>Ctrl+Shift+T</strong> 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</li>
<li>将链接拖动到标签页内 在指定标签页中打开链接</li>
<li>将链接拖动到两个标签页之间 在标签页横条的指定位置建立一个新标签页，在该标签页中打开链接</li>
<li>Ctrl+1 到 Ctrl+8 切换到指定位置编号的标签页。您按下的数字代表标签页横条上的相应标签位置。</li>
<li>Ctrl+9 切换到最后一个标签页</li>
<li><strong>Ctrl+Tab 或 Ctrl+PgDown</strong> 切换到下一个标签页,这里和vimium中的H功能一样，不过都要记住</li>
<li><strong>Ctrl+Shift+Tab 或 Ctrl+PgUp</strong> 切换到上一个标签页，vimium下的L</li>
<li><strong>Ctrl+W 或 Ctrl+F4</strong> 关闭当前标签页或弹出式窗口</li>
<li><strong>Alt+Home</strong> 打开主页</li>
</ul>


<p><strong>Chrome地址栏快捷键</strong></p>

<ul>
<li>键入搜索字词 使用默认搜索引擎进行搜索</li>
<li>键入网址中”www.”和”.com”之间的部分，然后按Ctrl+Enter 键 为您在地址栏中输入的内容添加”www.”和”.com”，然后打开网址</li>
<li>键入搜索引擎关键字或网址，按 Tab键，然后键入搜索字词 使用与关键字或网址相关联的搜索引擎进行搜索。如果谷歌浏览器可以识别您要使用的搜索引擎，则会提示您按 Tab 键。</li>
<li>F6 或 Ctrl+L 或 Alt+D 选中网址区域中的内容</li>
<li>键入网址，然后按 Alt+Enter 键 在新标签页中打开网址</li>
<li>打开谷歌chrome浏览器各功能的快捷键</li>
<li><strong>Ctrl+B</strong> 打开和关闭书签栏</li>
<li><strong>Ctrl+Shift+B</strong> 打开书签管理器</li>
<li><strong>Ctrl+H</strong> 查看”历史记录”页</li>
<li><strong>Ctrl+J</strong> 查看”下载”页</li>
<li>Shift+Escape 查看任务管理器</li>
<li>Shift+Alt+T 将焦点设置在工具栏上。使用键盘上的向右和向左箭头，可导航至工具栏上的不同按钮。</li>
</ul>


<p><strong>Chrome网页快捷键</strong></p>

<ul>
<li>Ctrl+P 打印当前页</li>
<li>Ctrl+S 保存当前页</li>
<li>F5 重新加载当前页</li>
<li>Esc 停止加载当前页</li>
<li>Ctrl+F 打开”在网页上查找”框</li>
<li>点击鼠标中键或滚轮（只在谷歌浏览器测试版（只有英文版）中可用） 激活自动滚动。当您移动鼠标时，网页会根据鼠标的移动方向自动滚动。</li>
<li>Ctrl+F5 或 Shift+F5 重新加载当前页，但忽略缓存内容</li>
<li>按住 Alt 键，然后点击链接 下载链接</li>
<li><strong>Ctrl+G 或 F3</strong> 查找与您在”在网页上查找”框中输入的内容相匹配的下一个匹配项</li>
<li>Ctrl+Shift+G 或 Shift+F3 查找与您在”在网页上查找”框中输入的内容相匹配的上一个匹配项</li>
<li><strong>Ctrl+U</strong> 查看源代码</li>
<li>将链接拖动到书签栏 将链接加入书签</li>
<li><strong>Ctrl+D</strong> 将当前网页加入书签</li>
<li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容</li>
<li>Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容</li>
<li>Ctrl+0 将网页上的所有内容都恢复到正常大小</li>
<li>选中内容，然后按 Ctrl+C 键 将内容复制到剪贴板</li>
<li>将光标置于文本字段中，然后按 Ctrl+V 或 Shift+Insert 键 从剪贴板粘贴当前内容</li>
<li>将光标置于文本字段中，然后按 <strong>Ctrl+Shift+V</strong> 键 从剪贴板粘贴当前内容的纯文本部分</li>
<li>选中文字字段中的内容，然后按 Ctrl+X 或Shift+Delete 键 删除内容并将其复制到剪贴板</li>
</ul>


<hr />

<h4>Vimium下的快捷键</h4>

<p>与chrome算是绝配，有如虎添翼之感．Geek神器，大神必备</p>

<ul>
<li>j: 向下移动。</li>
<li>k：向上移动。（不明白默认的表示是啥用法，使用了c-y这三个键没有效果）</li>
<li>h：向左移动。</li>
<li>l：向右移动。</li>
<li>zH：一直移动到左部。</li>
<li>zL:一直移动到右部。</li>
<li>gg：跳转到页面的顶部。</li>
<li>G：跳转到页面的底部。</li>
<li><strong>d：向下翻页</strong>（相当于PageDown被按下了）</li>
<li><strong>u：向上翻页</strong>（相当于PageUp被按下了）</li>
<li>r：重新载入该页（相当于F5刷新页面）</li>
<li><strong>gs：查看页面源代码</strong> 等于chrome下的Ctrl+U</li>
<li><strong>yy：拷贝当前页面的URL到剪贴板</strong>当前页面</li>
<li>yf：拷贝某一个URL到剪贴板（实际上是相当于输入了f，然后出现很多编码的URL，选择某个之后，相当于拷贝了某个，因为一个页面中可能有很多超链接）</li>
<li><strong>gu：跳转到父页面</strong>（比如<a href="http://www.douban.com/group/vim/%EF%BC%8C%E8%BE%93%E5%85%A5%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8D%B3http://www.douban.com/group/%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BA%8EH%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%AF%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2%EF%BC%89">http://www.douban.com/group/vim/%EF%BC%8C%E8%BE%93%E5%85%A5%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8D%B3http://www.douban.com/group/%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BA%8EH%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%AF%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2%EF%BC%89</a></li>
<li>i：输入模式（如果发现命令不起作用，可能是进入输入模式了，此时按Esc回到命令模式）</li>
<li><strong>gi：将焦点集中到第一个输入框</strong>（输入gNi则焦点集中到第N个输入框）</li>
<li>f：在当前的页面打开一个新的链接。</li>
<li>F：在新的页面打开一个新的链接。</li>
<li>:在当前页面打开多个链接（没感觉使用到了多个标签，不过表示的是输入af）</li>
<li><strong>b：在当前页打开一个书签</strong>。（输入部分网址会自动进行搜索）</li>
<li><strong>B：在新的标签页打开一个书签</strong></li>
<li>gf：循环到当前页面的下一个框层（可能跟页面制作有关，目前没用到）</li>
<li>/ : 查找</li>
<li>n: 向下查找匹配内容</li>
<li>N：向上查找匹配内容</li>
<li><strong>H：回退上一个历史页面（相当于浏览器中的向左箭头）Ctrl+Tab或者Ctrl+PageDown</strong></li>
<li><strong>L：回到下一个历史页面（相当于浏览器的向右箭头）</strong></li>
<li><strong>K，gt：跳转到右边的一个标签页</strong></li>
<li><strong>J，gT：跳转到左边的一个标签页</strong> 和chrome下的Ctrl+9一样．</li>
<li>t：创建一个新的标签页</li>
<li><strong>x：关闭当前的标签页</strong> = Ctrl+W</li>
<li><strong>X：恢复刚刚关闭的标签页</strong> = Ctrl+Shift+T</li>
<li><strong>？：显示命令的帮助提示（再按一次关闭）</strong></li>
</ul>


<hr />

<p>还有一些通用的快捷键：</p>

<ul>
<li>空格</li>
<li>PageUp, PageDown, Array</li>
<li>Home, End, Insert</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ssh无密码登录]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/15/sshwu-mi-ma-deng-lu/"/>
    <updated>2014-07-15T00:30:04+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/15/sshwu-mi-ma-deng-lu</id>
    <content type="html"><![CDATA[<h4>ssh无密码登录</h4>

<!--more-->


<p>ssh应用太广，最常用的就是远程登录和文件传输了，每次输入密码和登录确实很浪费时间，这里就不需要输入密码了</p>

<h5>设置</h5>

<ul>
<li><ol>
<li>在客户端．生成密钥<code>ssh-keygen -t rsa</code>，这样在~/.ssh文件夹中就会有一个公钥和一个私钥</li>
</ol>
</li>
<li><ol>
<li>服务端，在~/.ssh中，将客户端的id_rsa.phb放到这里，<code>scp .ssh/id_rsa.phb ip:.ssh/authorizend_keys</code>，也可以命名其它的</li>
</ol>
</li>
<li><ol>
<li>再登录时就可以不用输入密码．也可以把登录alias写入bash中，scp时也不用输入密码，但是还是要记住ip</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed入门]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/14/sedru-men/"/>
    <updated>2014-07-14T21:26:23+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/14/sedru-men</id>
    <content type="html"><![CDATA[<h4>Sed入门</h4>

<p>sed &ndash; stream editor for filtering and transforming text</p>

<p>sed是非交互式编辑器，很强大．掌握了将得心应手．命令很简单，关键是熟练运用．入门也很简单．估计一个小时内就了解了</p>

<!--more-->


<h5>特点</h5>

<ul>
<li>1.sed不会修改文件</li>
<li>2.默认所有的输出行都被打印到屏幕上.具体是读入一行到缓冲区，处理这一行，发送到屏幕，删除缓冲区内容，处理下一行</li>
<li><ol>
<li>sed [选项]&hellip; {脚本(如果没有其他脚本)} [输入文件]&hellip;</li>
</ol>
</li>
<li><ol>
<li>sed不管是否找到指定的模式，它的退出状态都是0。只有当命令存在语法错误时，sed的退出状态才不是0</li>
</ol>
</li>
</ul>


<h5>命令和选项</h5>

<table>
<thead>
<tr>
<th>命令　    </th>
<th> 解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>a\        </td>
<td>在当前行后添加一行或多行。多行时除最后一行外，每行末尾需用“\”续行</td>
</tr>
<tr>
<td> c\ </td>
<td> 用此符号后的新文本替换当前行中的文本。多行时除最后一行外，每行末尾需用&#8221;\&ldquo;续行</td>
</tr>
<tr>
<td> i\ </td>
<td> 在当前行之前插入文本。多行时除最后一行外，每行末尾需用&#8221;\&ldquo;续行</td>
</tr>
<tr>
<td> d  </td>
<td> 删除行</td>
</tr>
<tr>
<td> h  </td>
<td> 把模式空间里的内容复制到暂存缓冲区</td>
</tr>
<tr>
<td> H  </td>
<td> 把模式空间里的内容追加到暂存缓冲区</td>
</tr>
<tr>
<td> g  </td>
<td> 把暂存缓冲区里的内容复制到模式空间，覆盖原有的内容</td>
</tr>
<tr>
<td> G  </td>
<td> 把暂存缓冲区的内容追加到模式空间里，追加在原有内容的后面</td>
</tr>
<tr>
<td> l  </td>
<td> 列出非打印字符</td>
</tr>
<tr>
<td> p  </td>
<td> 打印行</td>
</tr>
<tr>
<td> n  </td>
<td> 读入下一输入行，并从下一条命令而不是第一条命令开始对其的处理</td>
</tr>
<tr>
<td> q  </td>
<td> 结束或退出sed</td>
</tr>
<tr>
<td> r  </td>
<td> 从文件中读取输入行</td>
</tr>
<tr>
<td> !  </td>
<td> 对所选行以外的所有行应用命令</td>
</tr>
<tr>
<td> s  </td>
<td> 用一个字符串替换另一个</td>
</tr>
<tr>
<td> g  </td>
<td> 在行内进行全局替换</td>
</tr>
<tr>
<td> w  </td>
<td> 将所选的行写入文件</td>
</tr>
<tr>
<td> x  </td>
<td> 交换暂存缓冲区与模式空间的内容</td>
</tr>
<tr>
<td> y  </td>
<td> 将字符替换为另一字符（不能对正则表达式使用y命令）</td>
</tr>
<tr>
<td> -e </td>
<td>    进行多项编辑，即对输入行应用多条sed命令时使用</td>
</tr>
<tr>
<td> -n </td>
<td>   取消默认的输出</td>
</tr>
<tr>
<td> -f </td>
<td>  指定sed脚本的文件名</td>
</tr>
</tbody>
</table>


<h5>正则表达式</h5>

<p>**正则表达式要括在斜杠线&#8221;/&ldquo;之间.如果要把正则表达式分隔符&rdquo;/&ldquo;改为另一个字符，比如o，则&rdquo;\o..o&#8221;,例如：sed -n &lsquo;\o<sup>Myop</sup>&rsquo; datafile</p>

<table>
<thead>
<tr>
<th>元字符   </th>
<th> 功能            </th>
<th>   示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^ </td>
<td> 行首定位符 </td>
<td> /^my/  匹配所有以my开头的行</td>
</tr>
<tr>
<td>$  </td>
<td>   行尾定位符 </td>
<td> /my$/  匹配所有以my结尾的行</td>
</tr>
<tr>
<td>.  </td>
<td>  匹配除换行符以外的单个字符 </td>
<td> /m..y/  匹配包含字母m，后跟两个任意字符，再跟字母y的行</td>
</tr>
<tr>
<td>*  </td>
<td> 匹配零个或多个前导字符 </td>
<td> /my*/  匹配包含字母m,后跟零个或多个y字母的行</td>
</tr>
<tr>
<td>[] </td>
<td>匹配指定字符组内的任一字符 </td>
<td> /[Mm]y/  匹配包含My或my的行</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在指定字符组内的任一字符</td>
<td>/[^Mm]y/  匹配包含y，但y之前的那个字符不是M或m的行</td>
</tr>
<tr>
<td> (..)</td>
<td>   保存已匹配的字符 </td>
<td>   1,20s/(you)self/\1r/  标记元字符之间的模式，并将其保存为标签1，之后可以使用\1来引用它。最多可以定义9个标签，从左边开始编号，最左边的是第一个。此例中，对第1到第20行进行处理，you被保存为标签1，如果发现youself，则替换为your。</td>
</tr>
<tr>
<td>&amp; </td>
<td>保存查找串以便在替换串中引用</td>
<td>s/my/<strong>&amp;</strong>/  符号&amp;代表查找串。my将被替换为<strong>my</strong></td>
</tr>
<tr>
<td>&lt;</td>
<td>词首定位符 </td>
<td> /&lt;my/  匹配包含以my开头的单词的行</td>
</tr>
<tr>
<td>></td>
<td>词尾定位符</td>
<td>/my>/|  匹配包含以my结尾的单词的行</td>
</tr>
<tr>
<td>x{m}</td>
<td>连续m个x</td>
<td>/9{5}/ 匹配包含连续5个9的行</td>
</tr>
<tr>
<td>x{m,}</td>
<td>至少m个x</td>
<td>/9{5,}/  匹配包含至少连续5个9的行</td>
</tr>
<tr>
<td>x{m,n}</td>
<td>至少m个，但不超过n个x</td>
<td>/9{5,7}/  匹配包含连续5到7个9的行</td>
</tr>
</tbody>
</table>


<h5>示例</h5>

<pre><code>sed '2,5d' file删除2到5行
sed '/My/,/You/d' file 删除包含My的和到包含You之间的行
sed '$d' file删除最后一行，其余的打印
sed '/my/p' file把所有行打印一次，再把包含my的行打印一次
sed -n '/my/p' file -n取消了默认打印，只打印匹配项
sed 's/^my/you/g' file 替换my为you,g表示所有的都替换
sed -n '2,20s/my$/you/gp' file 替换，并只打印替换的行，上一个会默认全打印
sed -e '1,100d' -e 's/a/b/g' file多重编辑
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最系列]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/"/>
    <updated>2014-07-13T19:58:08+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie</id>
    <content type="html"><![CDATA[<h4>最系列</h4>

<p>常见到最长子序列，最长公共子序列等，网上总结了也很多．但自己实现一次方才了解．发现收获很多的．</p>

<h4>目录</h4>

<ul>
<li>1.<a href="#1">最长公共子序列</a></li>
<li>2.<a href="#2">最长公共子串</a></li>
<li>3.<a href="#3">最长重复子串</a></li>
<li>4.<a href="#4">最长回文子串</a></li>
<li>5.<a href="#5">最大递增子序列</a></li>
<li>6.<a href="#6">最大子数组和</a></li>
<li>7.<a href="#7">最大M子段和</a></li>
<li>8.<a href="#8">最大和子矩阵</a></li>
<li>9.<a href="#9">字符串编码距离</a></li>
<li>10.<a href="#10">最长不重复子串</a></li>
</ul>


<!--more-->




<h5 id="1">最长公开子序列</h5>


<p>这个最基础，动态规划；转移方程:</p>

<p>C[i,j] = 0; 初始</p>

<p>C[i,j] = C[i-1,j-1] + 1; Xi = Yi</p>

<p>C[i,j] = max(C[i-1,j], C[i,j-1]); Xi != Yi;</p>

<p>**代码</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int LCS(char *str1, char *str2, int m, int n, int len[][100],int sub[][100])
{
        int i,j;
        for(i=0;i&lt;m;i++)
            len[i][0] = 0;
        for(i=0;i&lt;n;i++)
            len[0][i] = 0;
        for(i=1;i&lt;=m;i++)
        for(j=1;j&lt;=n;j++)
        {
            if(str1[i-1]==str2[j-1])
            {
                len[i][j] = len[i-1][j-1] + 1;
                sub[i][j] = 0;
            }
            else if(len[i-1][j]&gt;=len[i][j-1])
            {
                len[i][j] = len[i-1][j];
                sub[i][j] = 1;
            }
            else
            {
                len[i][j] = len[i][j-1];
                sub[i][j] = -1;
            }
        }
        return len[m][n];
}

void PrintSub(char *x,int i, int j, int b[][100])
{
    if(i==0||j==0)
        return;
    if(b[i][j] == 0)
    {
        PrintSub(x,i-1,j-1,b);
        printf("%c",x[i-1]);
    }
    else if(b[i][j]==1)
        PrintSub(x,i-1,j,b);
    else 
        PrintSub(x,i,j-1,b);
    return ;
}
int main()
{
    char str1[100],str2[100];
    int len1,len2;
    int subq[100][100],subq_len[100][100]; 
    while(~scanf("%s %s",str1,str2))
    {
        len1 = strlen(str1); 
        len2 = strlen(str2); 
        int len = LCS(str1,str2,len1,len2,subq_len,subq);
        printf("%d\n",len);
        PrintSub(str1,len1,len2,subq);
        printf("\n");
    }
    return 0;
}
</code></pre>

<h5 id="2">最长公开子串</h5>


<p>串和序列的区别在于连续与否，两者实现也差不多</p>

<p>**代码</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int LCS(char *str1, char *str2, int m, int n, char *str3, int len[][100])
{
        int i,j;
        int max = -1;
        int x,y;
        int k;
        for(i=0;i&lt;m;i++)
            len[i][0] = 0;
        for(i=0;i&lt;n;i++)
            len[0][i] = 0;
        for(i=1;i&lt;=m;i++)
        for(j=1;j&lt;=n;j++)
        {
            if(str1[i-1]==str2[j-1])
                len[i][j] = len[i-1][j-1] + 1;
            else 
                len[i][j] = 0;
            if(len[i][j]&gt;max)
            {
                max = len[i][j];
                x = i;
                y = j;
            }
        }
        k = max;
        str3[k] = '\0';
        while(k&gt;=0)
            str3[--k] = str1[--x];
        return max;
}

int main()
{
    char str1[100],str2[100];
    char str3[100];
    int len1,len2;
    int subq_len[100][100]; 
    while(~scanf("%s %s",str1,str2))
    {
        len1 = strlen(str1); 
        len2 = strlen(str2); 
        int len = LCS(str1,str2,len1,len2,str3,subq_len);
        printf("%s\n",str3);
        printf("%d\n",len);
    }
    return 0;
}
</code></pre>

<h5 id="6">最大子数组和</h5>


<p>即一个数组中连续元素和的最大值，如1,2,-4,2 最大是3</p>

<p>**代码:　</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main()
{
    int n, a[100];
    int i,sum,tmp;
    int maxsum ;
    while(~scanf("%d",&amp;n))
    {
        maxsum = INT_MIN;
        sum = tmp = 0;
        for(i=0;i&lt;n;i++)
        {
            scanf("%d",&amp;a[i]);
            tmp += a[i];
            if(tmp&lt;0)
                tmp = 0;
            else
                sum = tmp;
            if(sum&gt;maxsum)
                maxsum = sum;
        }
        if(maxsum&lt;=0)
        {
            maxsum = a[0];
            for(i=0;i&lt;n;i++)
                if(a[i]&gt;maxsum)
                    maxsum = a[i];
        }
        printf("%d\n",maxsum);
    }
    return 0;
}
</code></pre>

<h5 id="5">最大子数组</h5>


<p>序列可以为数组，也可以为特别的结构体，原理应该是一样的
**代码：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//return the length
int LongIncreaseSubsquence1(int *a, int n, int *b)
{
    int i,j;
    int lenght = 1;
    if(n&lt;=0)return 0;
    if(n==1)return 1;
    b[0] = 1;
    for(i=1;i&lt;n;i++)
    {
        b[i] = 1;
        for(j=0;j&lt;i;j++)
        {
            if(a[j]&lt;a[i]&amp;&amp;b[j]+1&gt;b[i])
               b[i] = b[j] + 1;
        }
    }
    for(i=1;i&lt;n;i++)
        lenght = (lenght&gt;=b[i]?lenght:b[i]);
    return lenght;
}
int main()
{
    int a[100];
    int b[100];
    int n,i;
    while(~scanf("%d",&amp;n))
    {
        for(i=0;i&lt;n;i++)
            scanf("%d",&amp;a[i]);
        int len = LongIncreaseSubsquence1(a,n,b);
        printf("%d\n",len);
    }
    return 0;
}
</code></pre>

<p>还有两种方法：
&ndash; 1.基于最长公共子序列，先把原串排序，再求最长公共子序列
&ndash; 2.再查找b[n]的时候，用二分法，因为b[n]是递增的序列</p>

<hr />

<h5>最大各子矩阵</h5>

<h5>最长重复子串</h5>

<h5>最长回文子串</h5>

<h5>最大M子段</h5>

<h5 id="9">字符编码距离</h5>


<p>两个字符串，从其中一个变为另外一个需要的操作次数就是编码距离，这个或者还有其它的名词称谓．</p>

<p>操作只有三种最基本的，即增删改，例如abc和bcd的距离就是，abc删除a，再后面添加d，操作就两步</p>

<p>这种有一个很简单的方法，基于最长公共子序列，首先求出最长公共子序列int len = GetLongestCommomSubsquence(str1,str2),然后得到两个字符串长度，len1,len2.则操作的距离是len1+len2-len*2</p>

<p>当这几个系列的操作都了解后，好多字符串的处理都是基于此的</p>

<hr />

<p><strong><em>待续</em></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[星月神话]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/13/xing-yue-shen-hua/"/>
    <updated>2014-07-13T16:03:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/13/xing-yue-shen-hua</id>
    <content type="html"><![CDATA[<h4>星月神话</h4>

<!--more-->


<p>参加葬礼一出．当地习俗，传承日久，势必请法师做法，戏子唱戏，乐队奏乐．亲朋来吊，乡里致哀，伤感不已．出殡之日，更是凝重无比．</p>

<p>古人有云：死生亦大矣．千古同此一叹．原本哀事，古人忌讳死，故曰喜．曰白喜事．</p>

<p>葬礼按部就班．唯乐队一曲＂<strong>星月神话</strong>＂，曲调哀婉，绵延幽长．旋律和缓，饱含感伤．虽原词歌诵爱情，流行已久，但于此处尤撩人伤怀，其音高于鞭炮礼花齐鸣，抑扬顿挫之调引人回忆．笛声悠扬，琴声绵长，更增凝重．曲调层层递进，情感步步难抑～</p>

<p><strong>＂千年之后的你会在哪里？身边有怎样风景＂</strong>．到此，几欲落泪.</p>

<hr />

<p><strong>星月神话，金莎</strong>(点击欣赏)</p>

<p>  <audio controls="controls">
  <source src="http://mkdir1.github.io/music/xing.mp3" type="audio/mpeg">
  </audio></p>

<pre><code>作词:金莎 作曲:金莎

我的一生最美好的场景
就是遇见你
在人海茫茫中静静凝望着你
陌生又熟悉

尽管呼吸着同一天空的气息
却无法拥抱到你
如果转换了时空身份和姓名
但愿认得你眼睛

千年之后的你会在哪里
身边有怎样风景
我们的故事并不算美丽
却如此难以忘记

尽管呼吸着同一天空的气息
却无法拥抱到你
如果转换了时空身份和姓名
但愿认得你眼睛

千年之后的你会在哪里
身边有怎样风景
我们的故事并不算美丽
却如此难以忘记

如果当初勇敢的在一起
会不会不同结局
你会不会也有千言万语
埋在沉默的梦里
</code></pre>

<hr />

<p>感时伤怀之作甚多，生离死别之事不少．屏幕电视演绎者再．若不经历生死，不目睹死别，诚不知容颜易老，韶华难再．俱各为前程，东奔西走，行色匆匆，始知相聚甚难. 纵为亲子，如之奈何？若抚遗像嗟悼，徒留回忆，岂不痛哉！</p>

<p>活在当下，珍惜眼前吧!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software for Blog on Ubuntu]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/12/software-for-blog-on-ubuntu/"/>
    <updated>2014-07-12T22:14:15+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/12/software-for-blog-on-ubuntu</id>
    <content type="html"><![CDATA[<h3>写博客常用到的工具</h3>

<p>磨刀不费砍柴功，看来工具真的很重要</p>

<p>今天网上又发现一些好东西</p>

<!--more-->


<h4>常用快捷键</h4>

<p>那些我知道的就不列了哈，找些实用但不常用的</p>

<ul>
<li><ol>
<li>C+Super+D</li>
</ol>
</li>
<li><ol>
<li>C+H 资源管理器中显示隐藏文件</li>
</ol>
</li>
<li><ol>
<li><strong>Alt+PrtSc截取窗口; Shift+PrtSc部分截取</strong>，这个比qq上的截取功能相似，很强大</li>
</ol>
</li>
<li><ol>
<li>Super+w 显示当前所有窗口，专业术语Expo模式</li>
</ol>
</li>
<li><ol>
<li>Super+S 缩小工作区，相当于点击了工作区的按键</li>
</ol>
</li>
<li><ol>
<li>Alt+F2弹出命令窗口，相当于Windows下的Win+R</li>
</ol>
</li>
<li><ol>
<li>Alt+Tab与Alt+｀一起使用，效果很酷</li>
</ol>
</li>
</ul>


<hr />

<h4>software</h4>

<ul>
<li><p>1.图片处理，mypaint,shotwell和gthumb. 前者是自带的，直接命令行下可用.都是ap-get install 就可得到的.设置好软件，可命令行启动.</p></li>
<li><ol>
<li>feedly查看rss的利器，但本人习惯用thunderbird. 主要是集成了邮件和rss，相对方便．　可以把feedly中获取非技术类的文章，有空的时候打开看看．　毕竟thunderbird太过臃肿，东西太多</li>
</ol>
</li>
<li><ol>
<li>Google Docs.编辑文档的很多，wps等，但是，一般我们要的是轻量级的编辑工具，而不是启动慢，工具选项多，操作不便的，大而全的工具．当然对于博客来说</li>
</ol>
</li>
<li><ol>
<li>Sublime 以后非命令行下，可以试试这个</li>
</ol>
</li>
<li><ol>
<li>Eclipse, Vim, Qt Creator, Sublime.各有一批拥趸．适合不同的开发者．Sublime适合前端，Vim通用，其它的集成，也很广泛</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Love-Letter Mystery]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/11/the-love-letter-mystery/"/>
    <updated>2014-07-11T14:55:48+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/11/the-love-letter-mystery</id>
    <content type="html"><![CDATA[<h4><a href="https://www.hackerrank.com/challenges/the-love-letter-mystery">The Love-Letter Mystery</a></h4>

<hr />

<p>James got hold of a love letter that his friend Harry has written for his girlfriend. Being the prankster that James is, he decides to meddle with it. He changes all the words in the letter into palindromes.</p>

<p>While modifying the letters of the word, he follows 2 rules:</p>

<p>(a) He always reduces the value of a letter, e.g. he changes &rsquo;d&#8217; to &lsquo;c&rsquo;, but he does not change &lsquo;c&rsquo; to &rsquo;d&#8217;.
(b) If he has to repeatedly reduce the value of a letter, he can do it until the letter becomes &lsquo;a&rsquo;. Once a letter has been changed to &lsquo;a&rsquo;, it can no longer be changed.</p>

<p>Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations he carries out to convert a given string into a palindrome.</p>

<!--more-->


<p>Input Format</p>

<p>The first line contains an integer T, i.e., the number of test cases.
The next T lines will contain a string each.</p>

<p>Output Format</p>

<p>A single line containing the number of minimum operations corresponding to each test case.</p>

<p>Constraints</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 ≤ T ≤ 10
</span><span class='line'>1 ≤ length of string ≤ 104 
</span><span class='line'>All characters are lower cased english letters.</span></code></pre></td></tr></table></div></figure>


<p>Sample Input #00</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3
</span><span class='line'>abc
</span><span class='line'>abcba
</span><span class='line'>abcd</span></code></pre></td></tr></table></div></figure>


<p>Sample Output #00</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2
</span><span class='line'>0
</span><span class='line'>4</span></code></pre></td></tr></table></div></figure>


<p>Explanation</p>

<p>For the first test case, ab<em>c</em> &ndash;> ab<em>b</em> &ndash;> ab<em>a</em>.
For the second test case, abcba is a palindromic string.
For the third test case, abc<em>d</em> &ndash;> abc<em>c</em> &ndash;> abc<em>b</em> &ndash;> abc<em>a</em> = ab<em>c</em>a &ndash;> ab<em>b</em>a.</p>

<hr />

<p>**The Code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

int main()
{
    int T,sum,j,diff;
    char str[10000];
    while(cin&gt;&gt;T)
        {
        for(int i=0;i&lt;T;i++)
            {
            cin&gt;&gt;str;
            int len = strlen(str);
            len -=1;
            sum = 0;
            j = 0;
            while(j&lt;len)
                {
                str[j]&gt;str[len]?diff=str[j]-str[len]:diff=str[len]-str[j];
                sum += diff;
                j++;
                len--;
            }
            cout&lt;&lt;sum&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>

<p><audio controls="controls">
  <source src="http://mkdir1.github.io/music/xing.mp3" type="audio/mpeg">
</audio></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gem-stones]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/11/gem-stones/"/>
    <updated>2014-07-11T14:38:44+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/11/gem-stones</id>
    <content type="html"><![CDATA[<h3><a href="https://www.hackerrank.com/challenges/gem-stones">Gem-stones</a></h3>

<p>John has discovered various rocks. Each rock is composed of various elements, and each element is represented by a lowercase latin letter from &lsquo;a&rsquo; to &lsquo;z&rsquo;. An element can be present multiple times in a rock. An element is called a &lsquo;gem-element&rsquo; if it occurs at least once in each of the rocks.</p>

<p>Given the list of rocks with their compositions, display the number of gem-elements that exist in those rocks.</p>

<!--more-->


<ul>
<li>Input Format</li>
</ul>


<p>The first line consists of N, the number of rocks.
Each of the next N lines contain rocks&#8217; composition. Each composition consists of lowercase letters of English alphabet.</p>

<ul>
<li>Output Format</li>
</ul>


<p>Print the number gem-elements that exist in those rocks.</p>

<p>Constraints</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 ≤ N ≤ 100 
</span><span class='line'>Each composition consists of only small latin letters ('a'-'z'). 
</span><span class='line'>1 ≤ Length of each composition ≤ 100</span></code></pre></td></tr></table></div></figure>


<p>Sample Input</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3
</span><span class='line'>abcdde
</span><span class='line'>baccd
</span><span class='line'>eeabg</span></code></pre></td></tr></table></div></figure>


<p>Sample Output</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2</span></code></pre></td></tr></table></div></figure>


<p>Explanation
Only &ldquo;a&rdquo;, &ldquo;b&rdquo; are the two kind of gem-elements, since these are the only characters that occur in each of the rocks&#8217; composition.</p>

<hr />

<p><strong>The Code</strong>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

int main()
{
    int N;
    int ele[26];
    char str[100];
    while(cin&gt;&gt;N)
    {
        int sum = 0;
        for(int i=0;i&lt;26;i++)ele[i]=1;
        for(int i=0;i&lt;N;i++)
        {
            cin&gt;&gt;str;
            int len = strlen(str);
            for(int j=0;j&lt;len;j++)
                if(ele[str[j]-'a']!=0)
                ele[str[j]-'a']++;
            for(int k=0;k&lt;26;k++)
            {        
                if(ele[k]&gt;1)
                    ele[k]=1;
                else
                    ele[k]=0;
            } 
        } 
        for(int j=0;j&lt;26;j++)
                if(ele[j]==1)sum++;

           printf("%d\n",sum);
        }

    return 0;    
}

---
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown转html和pdf]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/10/markdownzhuan-htmlhe-pdf/"/>
    <updated>2014-07-10T17:59:21+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/10/markdownzhuan-htmlhe-pdf</id>
    <content type="html"><![CDATA[<h3>Markdown转html和pdf</h3>

<p>这个功能很实用，可以在网上完成．但对于本地，则也有几个不错的工具选择</p>

<hr />

<!--more-->


<h4>之前的解决方案</h4>

<p>可以在这几个网址上完成转换:</p>

<ul>
<li><p>1 <a href="http://maxiang.info/">马克飞象</a>,这个很方便，可以同步evernote，b也有不错的界面，是目前我最看好的一个．但唯一不爽的是保存的pdf中竟然有它的logo这个真是要命</p></li>
<li><p>2 <a href="https://stackedit.io/">statedit</a>,这个也不错，和前者很像．应该大部分这类网站都是这个风格，在没有搭建好本地的转换的时候，本人一直是在这上面完成pdf转换的，想来真是折腾啊</p></li>
<li><p>3 再一个就是linux下的retext了，这是个简单的免费工具，文本操作，对于vim程序员确实使用不爽，唯一的用处就是预览和修改用</p></li>
<li><p>4 还好，linux下面有一个markdown的命令，使用也简单，也<code>sudo apt-get isntall markdwon</code>就行.不过令人不爽的是，html乱码，对中文支持不够，看了官网上的，好像还是2004年的更新，所以一定有我这样的志士仁人受不了</p></li>
</ul>


<hr />

<h5>现在的解决方案</h5>

<p>程序员的原则就是大道至简，其实就是方便，通俗点就是懒惰，怎么能忍受如此多的工具换来换去的，那岂不是要疯，最好是一个命令就搞定，生成了pdf, txt, html, md等所有格式，如果要用，就直接里面找．</p>

<p>首先安装<code>sudo apt-get install pandoc</code>，再看下它的方法，使用也很简单</p>

<p><strong>语法如下</strong></p>

<pre><code>pandoc -h
pandoc [OPTIONS] [FILES]
Input formats:  native, markdown, markdown+lhs, rst, rst+lhs, html, latex, latex+lhs
Output formats:  native, html, html+lhs, s5, docbook, opendocument, odt, latex, latex+lhs, context, texinfo, man, markdown, markdown+lhs, plain, rst, rst+lhs, mediawiki, rtf
Options:
  -f FORMAT, -r FORMAT  --from=FORMAT, --read=FORMAT                    
  -t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT                     
  -s                    --standalone                                    
  -o FILENAME           --output=FILENAME                               
  -p                    --preserve-tabs                                 
                        --tab-stop=TABSTOP                              
                        --strict                                        
                        --reference-links                               
  -R                    --parse-raw                                     
  -S                    --smart                                         
  -m[URL]               --latexmathml[=URL], --asciimathml[=URL]        
                        --mathml[=URL]                                  
                        --mimetex[=URL]                                 
                        --jsmath[=URL]                                  
                        --gladtex                                       
  -i                    --incremental                                   
                        --xetex                                         
  -N                    --number-sections                               
                        --no-wrap                                       
                        --sanitize-html                                 
                        --email-obfuscation=none|javascript|references  
                        --id-prefix=STRING                              
                        --indented-code-classes=STRING                  
                        --toc, --table-of-contents                      
                        --base-header-level=LEVEL                       
                        --template=FILENAME                             
  -V FILENAME           --variable=FILENAME                             
  -c URL                --css=URL                                       
  -H FILENAME           --include-in-header=FILENAME                    
  -B FILENAME           --include-before-body=FILENAME                  
  -A FILENAME           --include-after-body=FILENAME                   
  -C FILENAME           --custom-header=FILENAME                        
  -T STRING             --title-prefix=STRING                           
                        --reference-odt=FILENAME                        
  -D FORMAT             --print-default-template=FORMAT                 
                        --data-dir=DIRECTORY                            
                        --dump-args                                     
                        --ignore-args                                   
  -v                    --version                                       
  -h                    --help
</code></pre>

<p>支持格式中，比较有用的有**markdown, html, latex, rtf, odt</p>

<h4>使用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pandoc -f markdown -t html -o example.html example.md
</span><span class='line'>pandoc --ascii example.md -o example.html
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>加&mdash;ascii后html不会乱码</p>

<h4>转为pdf</h4>

<p>这个历程真是坑，转为pdf的软件何其多，当初很2的选择了xhtml2pdf.这个软件我至今还没安装好，依赖包好多，PIL, Reporlab．最后安装好了，还是出问题．当时的想法就是换一个软件．终于有一个神器出现了</p>

<pre><code>sudo apt-get install unoconv
</code></pre>

<p>使用也很方便，<code>unoconv -f pdf demo.html</code></p>

<p>为什么说<strong>unoconv</strong>是神器了，用了才知道它支持好多格式，常用的几乎包含了．</p>

<h4>写个Makefile就好了</h4>

<pre><code>MD = pandoc
MDFLAGS = --ascii
H2P = unoconv
H2PFLAGS = -f pdf 
SOURCES := $(wildcard *.md)
OBJECTS := $(patsubst %.md, %.html, $(wildcard *.md))
OBJECTS_PDF := $(patsubst %.md, %.pdf, $(wildcard *.md))
all: build
build: html pdf
pdf: $(OBJECTS_PDF)
html: $(OBJECTS)
$(OBJECTS_PDF): %.pdf: %.html
    $(H2P) $(H2PFLAGS) $&lt; 
$(OBJECTS): %.html: %.md
    $(MD) $(MDFLAGS) -o $@ $&lt;
clean:
    rm -f $(OBJECTS) *.pdf
</code></pre>

<p>这样再直接用就一切ok</p>

<h4>写个Shell一切安好</h4>

<p>这里整理一下要点</p>

<ul>
<li><ol>
<li>查找匹配后缀名<code>find * -type f -name '*.md'</code>，这里如果find后是.则匹配的文件有本目录如，./demo.md，如果用*则如demo.md</li>
</ol>
</li>
<li><p>2.匹配文件名和后缀，如果file=&ldquo;thisfile.md&rdquo;,则${file%.<em>}表示thisfile, ${file##</em>.}表示md</p></li>
</ul>


<p><strong>详细代码，我的shell名为tran.sh</strong></p>

<pre><code>#!/bin/sh                                                          
filelist=`find * -type f -name '*.md'`
for file in $filelist
do   
    htmlfile=${file%.*}.html
    pandoc --ascii $file -o $htmlfile
    unoconv -f pdf $htmlfile
done 
</code></pre>

<p>最后就放到bin中就搞定了</p>

<p>有的后缀很花样，没办法，把shell中两行改为:</p>

<pre><code>filelists=`find * -type f -name '*.markdown'`
for file in $filelist $filelists
</code></pre>

<p>Enjoy~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chocolate Feast]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/10/chocolate-feast/"/>
    <updated>2014-07-10T14:48:43+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/10/chocolate-feast</id>
    <content type="html"><![CDATA[<h3><a href="https://www.hackerrank.com/challenges/chocolate-feast">Chocolate Feast</a></h3>

<p>Little Bob loves chocolates, and goes to the store with N money in his pocket. The price of each chocolate is C . The store offers a discount: for every M wrappers he gives the store, he&rsquo;ll get one chocolate for free. How many chocolates does Bob get to eat?</p>

<p><strong>Input Format:</strong></p>

<blockquote><p>The first line contains the number of test cases $T (&lt;=1000)$.
T lines follow, each of which contains three integers N, C and M</p></blockquote>

<p><strong>Output Format:</strong></p>

<blockquote><p>Print the total number of chocolates Bob eats.</p></blockquote>

<!--more-->


<p><strong>Constraints:</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>$2 \le N \le 10^5$ 
</span><span class='line'>$1 \le C \le N$ 
</span><span class='line'>$2 \le M \le N$
</span></code></pre></td></tr></table></div></figure>


<p><strong>Sample input</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3
</span><span class='line'>10 2 5
</span><span class='line'>12 4 4
</span><span class='line'>6 2 2
</span></code></pre></td></tr></table></div></figure>


<p><strong>Sample Output</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>6
</span><span class='line'>3
</span><span class='line'>5
</span></code></pre></td></tr></table></div></figure>


<p><strong>Explanation</strong></p>

<p>In the first case, he can buy 5 chocolates with $\$10$ and exchange the 5 wrappers to get one more chocolate thus making the total number of chocolates he can eat as 6</p>

<p>In the second case, he can buy 3 chocolates for $\$12$. However, it takes 4 wrappers to get one more chocolate. He can&rsquo;t avail the offer and hence the total number of chocolates remains 3.</p>

<p>In the third case, he can buy 3 chocolates for $\$6$. Now he can give 2 of this 3 wrappers and get 1 chocolate. Again, he can use his 1 unused wrapper and 1 wrapper of new chocolate to get one more chocolate. Total is 5.</p>

<p><strong>The Code:</strong></p>

<pre><code>#include &lt;cmath&gt;
#include &lt;cstdio&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

int main() {
    int t,n,c,m,tmp;
    cin&gt;&gt;t;
    while(t--){
        cin&gt;&gt;n&gt;&gt;c&gt;&gt;m;
        int answer  = 0;
        int wrapper = 0;
        while(wrapper&gt;=m||n&gt;=c)
        {
            if(n&gt;=c)
            {
                answer += n/c;
                wrapper += answer;
                n %= c; 
            }
            if(wrapper&gt;=m)
            {
                answer += wrapper/m;
                tmp     = wrapper/m;
                wrapper %= m;
                wrapper += tmp;
            }
        }
        cout&lt;&lt;answer&lt;&lt;endl;
    }
    return 0;
}
</code></pre>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2014中国软件开发者调查报告CSDN]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/10/2014zhong-guo-ruan-jian-kai-fa-zhe-diao-cha-bao-gao-csdn/"/>
    <updated>2014-07-10T09:30:33+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/10/2014zhong-guo-ruan-jian-kai-fa-zhe-diao-cha-bao-gao-csdn</id>
    <content type="html"><![CDATA[<h3>2014中国软件开发者调查报告CSDN</h3>

<p>由CSDN发起的一项调查报告，有一定的可信度，值得每个程序员借鉴与思考．里面的数据需要简单分析一下，可对自己职业规划，业界现状，甚至人生都有一定的好处，现摘录加一点分析</p>

<p>可以到这里看全文<a href="http://www.csdn.net/article/2014-07-02/2820493?utm_source=tuicool">调查报告新闻</a></p>

<!--more-->


<hr />

<h5>相关数据</h5>

<ul>
<li><p>开发者男性为主导，特别是年轻男性，21~30岁占82%，硕士15%, 本科64%</p></li>
<li><p>北上广深成都调查者占近一半</p></li>
<li><p>30岁以上从事开发者很少</p></li>
<li><p>创业的比例和想要创业的人的比例</p></li>
</ul>


<p><img src="http://mkdir1.github.io/images/baogao1.jpg" alt="创业" /></p>

<ul>
<li>操作系统使用比例</li>
</ul>


<p><img src="http://mkdir1.github.io/images/baogao2.jpg" alt="操作系统" /></p>

<ul>
<li>行业细分</li>
</ul>


<p><img src="http://mkdir1.github.io/images/baogao3.jpg" alt="行业" /></p>

<ul>
<li>语言分类</li>
</ul>


<p><img src="http://mkdir1.github.io/images/baogao4.jpg" alt="语言" /></p>

<hr />

<h5>可以看出</h5>

<ul>
<li><p>1 大城市一般是IT行业者的理想栖息地，不仅仅工资可观，而且机会众多，不少企业和研究所都坐落于此，所以，这也解释了为什么这个行业可选的地方也就少有的几个大中城市</p></li>
<li><p>2 创业没有什么年龄段，有机会就要上，而且比例还不占少数，而真正实践的确不多</p></li>
<li><p>3 女性在这个行业竞争确实有限，大部分到一定年龄就退出了，不知以后是否有变化，我估计也改变不大</p></li>
<li><p>4 操作系统移动端的上升明显，linux和windown地位目前不可撼动</p></li>
<li><p>5 有必要学会这几种语言<strong>Java, C#, C++/C, PHP, JavaScript, Python</strong></p></li>
</ul>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C语言中char *a与char A[]的区别]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/09/cyu-yan-zhong-char-star-ayu-char-a-de-qu-bie/"/>
    <updated>2014-07-09T23:41:57+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/09/cyu-yan-zhong-char-star-ayu-char-a-de-qu-bie</id>
    <content type="html"><![CDATA[<h4>C语言char s[] 和 char *s的区别</h4>

<p>看如下的代码，区别立现</p>

<pre><code>char *s = "hello world";
char s[] = "hello world"
</code></pre>

<p>区别在于<strong>前者是指针，后者是数组</strong></p>

<pre><code>char *s是一个指向只读区域的指针，只读区域是hello world
char s[]是一个数组，内容是拷贝了只读区别的数据
</code></pre>

<p>前者指针指向的内容不能变，后者可变</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux启动流程]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/09/linuxqi-dong-liu-cheng/"/>
    <updated>2014-07-09T23:14:18+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/09/linuxqi-dong-liu-cheng</id>
    <content type="html"><![CDATA[<h4>Linux的启动顺序</h4>

<ul>
<li><p>1 加载BIOS的硬件信息并进行自检，然后根据设置取得第一个可启动的设备；</p></li>
<li><p>2 读取并执行第一个启动设备内MBR(master boot record,主引导分区)的boot loader；</p></li>
<li><p>3 依据bootloader的设置加载kernel，kernel开始检测硬件和加载驱动程序；</p></li>
</ul>


<!--more-->


<ul>
<li><p>4 在硬件驱动成功后，kernel会调用init进程，init进程会取得run-level信息；</p></li>
<li><p>5 init执行/etc/rc.d/sysinit文件来准备软件执行的操作环境；</p></li>
<li><p>6 init执行run-level的各个服务；</p></li>
<li><p>7 init执行/etc/rc.d/rc.local文件；</p></li>
<li><p>8 init执行终端机模拟程序mingetty来启动login进程，最后等待用户登录。</p></li>
</ul>


<hr />

<h4>用户登录后</h4>

<ul>
<li><p>1 /etc/profile：此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行. 并从/etc/profile.d目录的配置文件中搜集shell的设置。</p></li>
<li><p>2 /etc/bashrc: 为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。</p></li>
<li><p>3 ~/.bash_profile: 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件。</p></li>
<li><p>4 ~/.bashrc: 该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取。</p></li>
<li><p>5 ~/.bash_logout:当每次退出系统(退出bash shell)时,执行该文件.  另外,/etc/profile中设定的变量(全局)的可以作用于任何用户,而~/.bashrc等中设定的变量(局部)只能继承 /etc/profile中的变量,他们是&#8221;父子&#8221;关系。</p></li>
<li><p>6 ~/.bash_profile 是交互式、login 方式进入 bash 运行的~/.bashrc 是交互式 non-login 方式进入 bash 运行的通常二者设置大致相同，所以通常前者会调用后者。</p></li>
</ul>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linux下常用的软件汇集]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/09/linuxxia-chang-yong-de-ruan-jian-hui-ji/"/>
    <updated>2014-07-09T20:29:04+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/09/linuxxia-chang-yong-de-ruan-jian-hui-ji</id>
    <content type="html"><![CDATA[<h3>Linux下常用的软件合集</h3>

<p>自己所用的环境一直是Linux,版本是最新的Ubuntu14.04.</p>

<p>其它版本的linux未尝试，实属遗憾，先把自己所用的环境整理一番</p>

<!--more-->


<hr />

<h4>工作必备</h4>

<ul>
<li>Chrome/Firefox.(Vimium)</li>
<li>Thunderbird</li>
<li>为知笔记(Evernote也很不错，不过在linux下只有这个支持得不错，且用户量也大)</li>
<li>搜狗五笔(支持linux真心不错，业界良心，其它的什么一直使用不便)</li>
<li>Samba</li>
<li>QQ，（这个需要自己想办法，不过至今有一个完全支持的版本，总是bug不断)</li>
<li>Ffmpeg&amp;VLC</li>
<li>rdesktop</li>
<li>syspeek</li>
<li>deeping-Music-play</li>
<li>wps&amp;liboffice(有些要自己安装)</li>
<li>星际译王</li>
<li>unoconv和pandoc</li>
<li>synergy</li>
<li>skype</li>
<li>variety(这个软件使得Linux有了windows上aero的效果)</li>
<li>Dropbox</li>
<li>OpenFetion</li>
<li>Filezilla
&ndash;. Freemind</li>
<li>Wine</li>
<li>豆瓣fm</li>
<li>Tweak</li>
<li>Gimp</li>
<li>SMplayer</li>
<li>Adobe Flash</li>
<li>福昕PDF</li>
<li>Cairo-Dock(这个搞得像Mac)</li>
<li>抓虾(git上的zx)</li>
</ul>


<hr />

<h4>程序员必备</h4>

<p>这个应该没什么是必备的，程序员的世界无法看遍．下面是老夫用的，bin下面一大堆，只列几个正在用的</p>

<ul>
<li>Vim(推荐k-vim)</li>
<li>QT</li>
<li>retext</li>
<li>eclipse</li>
<li>mysql</li>
<li>python</li>
<li>git&amp;svn</li>
<li>ssh</li>
<li>Wireshark</li>
<li>codeblocks</li>
<li>Texmaker</li>
<li>VirtualBox</li>
<li>JAVA</li>
<li>g++</li>
</ul>


<hr />

<h5>原则</h5>

<ul>
<li>不折腾不舒服，不尝试无发言权</li>
<li>数学和音乐让我又度过了无聊的一天</li>
<li>一天不学，落后</li>
<li>记在纸上的，永远记不住</li>
<li>用不上的，最好不要学，除非是装13</li>
<li>永远不要看电视剧，看下情节概要就行</li>
<li>人生如戏，就看演技　</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdonw语法简要]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/09/markdonwyu-fa-jian-yao/"/>
    <updated>2014-07-09T16:39:07+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/09/markdonwyu-fa-jian-yao</id>
    <content type="html"><![CDATA[<h3>Markdonw语法简要</h3>

<p>此处权当工具参考之用，可覆盖90%应用</p>

<!--more-->


<hr />

<h5>标题和加粗斜体</h5>

<ul>
<li>用#的个数表示标题大小</li>
<li>粗体和斜体用星号来括起来</li>
</ul>


<hr />

<h5>图片和链接</h5>

<ul>
<li><p>链接
[linkname](url,&ldquo;description&rdquo;)</p></li>
<li><p>图片 <br/>
![name](url,&ldquo;title&rdquo;)
  直接&lt;img>标签可以改变大小，这个可以尝试</p></li>
<li><p>两者都可以引用表示</p></li>
</ul>


<hr />

<h5>引用</h5>

<ul>
<li>在行首加上&lt;即可，可嵌套使用</li>
<li>引用内可支持其它的Markdown语法</li>
<li>\用来转义</li>
</ul>


<h5>列表</h5>

<ul>
<li>使用+/-/*俱可</li>
</ul>


<h5>代码块</h5>

<ul>
<li>代码块用一个tab或四个空格，块内的格式将保留，一直会持续到没有tab或文件完</li>
<li>可直接加入html标签，但前后要加空行</li>
</ul>

]]></content>
  </entry>
  
</feed>
