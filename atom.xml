<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-18T16:59:44+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[李天一列传]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/li-tian-%5B%3F%5D-lie-chuan/"/>
    <updated>2014-07-18T16:57:08+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/li-tian-[?]-lie-chuan</id>
    <content type="html"><![CDATA[<h4>屎记　李天一列传</h4>

<p><strong>屎记　李天一列传</strong></p>

<p><strong>文兄</strong></p>

<!--more-->


<hr />

<pre><code> 李天一，字冠丰，长安海淀人也。父两江，伶官也，以狎歌得宠，捧之歌王，颇得上赞许，封誉无数。天一好游侠，喜交接，眉清目秀，雄姿英发。尝与父同演，时人渐知其名。母梦鸟，荧屏之上尽吐相夫教子之法。根正苗红，其所谓也。未冠既海内闻名，当世人奇之。

   天一孩提之时，便懂鼓琴，童龀之年，即会书法，幼学之际，渐通冰球。凡此种种，不一而足，可谓全才。其父甚喜，遂请名家教之。尝偕其交接权贵，以为后靠，现身荧屏，以养盛名。又系钟鸣鼎食之家，富家权贵之族，必国之大器也。天下第一，恰如其名，亦其父之所盼也。天一系老来子，捧之心肝，又类己，两江宠之尤甚。故宝马香车，无所不予，锦衣雕裘，毫不吝惜。少时米国游学，未冠既海归故里。

  天一好宝马，喜美色，甚类其父。尝驱马游街，风驰电掣之状，迅雷不及万一也。行人如遇鬼神，唯恐避之不及。天一见状，快然自乐。先时，天一与其友各得一名驹，相与赛驰。天一为别驾所阻，稍逊其友。见所阻者形容甚猥，乃恶语加之。然此人不知其大名，竟起而理论。当时，众友于侧，天一颜面尽失，怒发冲冠，挥拳相向。天一身长八尺，力能扛鼎，无与争锋。狂殴几死乃止。或唤巡捕房。天一愈怒曰：“敢生事者死！竖子焉知吾父其谁？” 乃扬长而去。有司惮其父威，息事宁人。其父多以钱财了结此事。天一遂骄恣日长，乃恣意纵情，豪掷千金，游逞市井，结交朋党，不务正业。

  及长，略懂云雨之事。尝闻天一侮其师，其师乃有夫之妇，畏两江夫妇淫威，不敢发。遂得诨名：海淀银枪小霸王。一晚，偕友数人章台游冶。酒酣耳热之际，灯火阑珊之处，见一女子，仪容艳丽，眉目清明。误以为陪酒，欲谋不轨。趁其醉，遂行苟且。天一素豪气，事毕亦念其党，可怜此女，数遭其辱。天一视若无事，恨未携相机，记此盛事。然此烈女，诉至大理寺，非钱财所能屈也。一时，世人哗然，海内震动，外邦亦引为笑谈。有司畏滔滔民意，汹汹舆情，不敢不察。两江素善钻研、勤于奔走，又门生故吏遍布朝野，多有名伶教授为之辩解，更添权贵为之开脱，指鹿为马、颠倒黑白更不在话下。或曰：此女系风尘，实索财未果反诬天一。又太学教授易延友曰：陪酒之女，人微命贱，侮之，其害甚小。梦鸟亦哭亦诉，其状生不如死，有司怜之。然不知梦鸟本两江之徒，素善演技。时平哥元年，始推新政，严惩腐败。国人久遭苛政，素淫官威。深恶权贵鱼肉。当时，群情激动，请愿之声不绝。纵两江四处走动，亦不免身败名裂，其子囹圄。

  文兄曰：昔陈涉诚不知王侯将相，确有其种。富贵之家，官宦子弟，本无饥寒之忧，无从业之虑。固其立业之机，倍于庶民，其功成之道，数于常人。 然其不争，流恶乡里，何也？ 古今纨绔之所同也！
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate Image]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/rotate-image/"/>
    <updated>2014-07-18T16:44:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/rotate-image</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/rotate-image/">Rotate Image</a></h4>

<h5>Problem:</h5>

<p>You are given an n x n 2D matrix representing an image.</p>

<p>Rotate the image by 90 degrees (clockwise).</p>

<p>Follow up:
Could you do this in-place?</p>

<!--more-->


<h5>Code:</h5>

<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)
    {
        int row = matrix.size();
        int col = matrix[0].size();
        // 
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;i;j++)
            swap(matrix[i][j],matrix[j][i]);
        //
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;col/2;j++)
            swap(matrix[i][j],matrix[i][col-1-j]);

    }
};
</code></pre>

<h5>说明</h5>

<ul>
<li><p>1.从windows下粘贴来的代码后面会有<sup>M</sup>的结尾，原因是换行符的约定问题，在vim中很容易删除，用:%s/^M//g即可，但此处的<sup>M</sup>需要用Ctrl+V再加上M得到</p></li>
<li><p>2.这题方法不是很多，先正对角线换，再左右换；或者逆对角线，再左右</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees Ii]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii/"/>
    <updated>2014-07-18T16:14:31+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/unique-binary-search-trees-ii/">Unique Binary Search Tree II</a></h4>

<!--more-->


<h5>Problem</h5>

<p>Given n, generate all structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n.</p>

<h5>Code</h5>

<pre><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode *&gt; generate(int beg, int end)
    {
        vector&lt;TreeNode* &gt; ret;
        if (beg &gt; end)
        {
            ret.push_back(NULL);
            return ret;
        }

        for(int i = beg; i &lt;= end; i++)
        {
            vector&lt;TreeNode* &gt; leftTree = generate(beg, i - 1);
            vector&lt;TreeNode* &gt; rightTree = generate(i + 1, end);
            for(int j = 0; j &lt; leftTree.size(); j++)
                for(int k = 0; k &lt; rightTree.size(); k++)
                {
                    TreeNode *node = new TreeNode(i + 1);
                    ret.push_back(node);
                    node-&gt;left = leftTree[j];
                    node-&gt;right = rightTree[k];              
                }           
        }

        return ret;
    }

    vector&lt;TreeNode *&gt; generateTrees(int n) {
        return generate(0, n - 1);
    }
};
</code></pre>

<h5>注意</h5>

<ul>
<li>1.此题第一想法就应试是递归或DFS</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insert Interval]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/insert-interval/"/>
    <updated>2014-07-18T15:40:02+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/insert-interval</id>
    <content type="html"><![CDATA[<h4>leetcode-Insert interval</h4>

<h5>题干</h5>

<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>

<p>You may assume that the intervals were initially sorted according to their start times.</p>

<p>Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>

<p>Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>

<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>

<!--more-->


<p>这题被虐了十几次，耗时半日．</p>

<p>其实逻辑简单，只是处理起来麻烦，如果有调试会更简单，只是平台上面只有结果．</p>

<h5>code</h5>

<pre><code>/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
bool  cmp(Interval interval1, Interval interval2)
{
        return interval1.start&lt;interval2.start;
}
class Solution {
public:

    vector&lt;Interval&gt; insert(vector&lt;Interval&gt; &amp;intervals, Interval newInterval) 
    {
         int size = intervals.size();
         intervals.push_back(newInterval);
         if(size==0)
            return intervals;  // pitfall1
        sort(intervals.begin(), intervals.end(), cmp);
        vector&lt;Interval&gt; result;
        int starts, ends;
        size++;
        int i,j;
        for(i=0;i&lt;size;i++)
        {
            starts = intervals[i].start;
            ends   = intervals[i].end;
            for(j=i+1;j&lt;size;j++)
            {
                if(ends&lt;intervals[j].start)
                  {
                    Interval tmp(starts, ends);
                    result.push_back(tmp);
                     break;
                  }
                 else if(ends&gt;=intervals[j].start&amp;&amp;ends&lt;=intervals[j].end)
                 {
                     ends = intervals[j].end;
                     i = j; //pitfall2
                 }
                 else
                    i = j; //pitfall3
            }
            if(size==j)
             {
                    Interval tmp(starts, ends);
                    result.push_back(tmp);
                    break;
             }
        }
        return result;
    }
};
</code></pre>

<p>三个pitfalls，首先按starts排序，然后遍历，其中要更新的不止是ends的值，还有是i也要更新，这样，就略过了．</p>

<h5>Bug</h5>

<ul>
<li><ol>
<li>关于sort排序，应该放在class之外，否则会报错</li>
</ol>
</li>
<li><ol>
<li>vector也有sort函数</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中sort报错]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/c-plus-plus-zhong-sortbao-cuo/"/>
    <updated>2014-07-18T12:25:35+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/c-plus-plus-zhong-sortbao-cuo</id>
    <content type="html"><![CDATA[<h4>C++中报错</h4>

<p><strong> no matching function for call to &lsquo;sort&rsquo;</strong></p>

<!--more-->


<p>具体：</p>

<p>代码如下：</p>

<pre><code>class Solution {
public:
bool  cmp(Interval interval1, Interval interval2)
{
        return interval1.start&lt;interval2.start;
};
int f()
{
    ...
    sort(intervals.begin(),intervals.end(),cmp);
    ...
}
};
</code></pre>

<p>此处用法错误，不知是否察觉：</p>

<p><strong> no matching function for call to &lsquo;sort&rsquo;</strong></p>

<p>解决之法：</p>

<p>将cmp的定义置于class之外</p>

<p>可以将sort定义在结构体之内，这样就直接intervals.sort(&hellip;)；如果定义在之外，要放在类的外面</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[添加用户]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/17/tian-jia-yong-hu/"/>
    <updated>2014-07-17T01:28:54+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/17/tian-jia-yong-hu</id>
    <content type="html"><![CDATA[<h4>Linux下添加用户　</h4>

<p>所涉及到的知识和概念比较多</p>

<!--more-->


<h5>命令</h5>

<p><strong>useradd</strong></p>

<pre><code>useradd [] name
-b, --base-dir BASE_DIR 新账户的主目录的基目录
-c, --comment COMMENT         新账户的 GECOS 字段
-d, --home-dir HOME_DIR       新账户的主目录
-D, --defaults      显示或更改默认的 useradd 配置
-e, --expiredate EXPIRE_DATE  新账户的过期日期
-f, --inactive INACTIVE       新账户的密码不活动期
-g, --gid GROUP     新账户主组的名称或 ID
-G, --groups GROUPS 新账户的附加组列表
-h, --help                    显示此帮助信息并推出
-k, --skel SKEL_DIR 使用此目录作为骨架目录
-K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
-l, --no-log-init   不要将此用户添加到最近登录和登录失败数据库
-m, --create-home   创建用户的主目录
-M, --no-create-home        不创建用户的主目录
-N, --no-user-group 不创建同名的组
-o, --non-unique        允许使用重复的 UID 创建用户
-p, --password PASSWORD     加密后的新账户密码
-r, --system                  创建一个系统账户
-R, --root CHROOT_DIR         chroot 到的目录
-s, --shell SHELL       新账户的登录 shell
-u, --uid UID           新账户的用户 ID
-U, --user-group        创建与用户同名的组
-Z, --selinux-user SEUSER       为 SELinux 用户映射使用指定 SEU
sudo useradd -d /home/hadoop/ -g adm -s /bin/bash hadoop
</code></pre>

<ul>
<li><ol>
<li>如果<code>-s /bin/sh</code>就会出现登录后只有一个$的情形，这是所选的shell出不对，应该换成/bin/bash</li>
</ol>
</li>
<li><ol>
<li>所选的目录应该事先就创建一个 <code>-d</code></li>
</ol>
</li>
<li><ol>
<li>-g 组名，可以查看<code>/etc/group</code>文件中的组名</li>
</ol>
</li>
</ul>


<p><strong>userdel</strong></p>

<pre><code>sudo userdel hadoop
</code></pre>

<p><strong>who,whoami,w,finger</strong>
这此命令查看相关用户情况，是个很常用的命令，用法也很简单</p>

<h5>概念</h5>

<p><strong>组的分类</strong>
&ndash; 1. 管理员 root:具有使用系统所有权限的用户,其UID 为0.
&ndash; 2. 普通用户: 即一般用户,其使用系统的权限受限,其UID为500-60000之间.
&ndash; 3. 系统用户 :保障系统运行的用户,一般不提供密码登录系统,其UID为1-499之间.</p>

<p><strong>文件</strong>
&ndash; 1．/etc/passwd文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>其格式：account：password：UID:GID:GECOS:diretory:shell
</span><span class='line'>        account: 用户名或帐号
</span><span class='line'>        password ：用户密码占位符
</span><span class='line'>        UID：用户的ID号
</span><span class='line'>        GID：用户所在组的ID号
</span><span class='line'>        GECOS:用户的详细信息（如姓名，年龄，电话等）
</span><span class='line'>        diretory：用户所的家目录
</span><span class='line'>        shell：用户所在的编程环境</span></code></pre></td></tr></table></div></figure>


<p>            <br/>
&ndash; 2. /etc/shadow</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>   其格式：account：password：最近更改密码的日期：密码不可更该的天数：密码需要重新更改的天数：密码更改前的警告期限：密码过期的宽限时间：帐号失效日期：保留</span></code></pre></td></tr></table></div></figure>


<p><strong>相关命令</strong>
usermod, groupdd</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记一次网络问题]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/17/ji-%5B%3F%5D-ci-wang-luo-wen-ti/"/>
    <updated>2014-07-17T00:12:42+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/17/ji-[?]-ci-wang-luo-wen-ti</id>
    <content type="html"><![CDATA[<h4>记一次网络问题及处理</h4>

<h5>问题描述</h5>

<p>周五的时候，网络还很好的，不论是外网还是内网，速度都正常．到周一的时候，速度特别慢，外网更慢．</p>

<p>速度慢，有的网站很快就刷出来，比如百度，so.com特，外网就很慢．qq聊天一切正常．内网中，局域网没问题，可以ping通网关和内网主机，并且ttl时间也很正常，没有延迟的现象</p>

<p>所有网站都可以访问，只是表现为速度慢，要加载很长时间</p>

<!--more-->


<h5>猜测原因</h5>

<p>由于近来，外网好多网站被封，所以外网访问慢的现象暂时没有考虑在内，倒是其它中平时常用的网站确实不能容忍．</p>

<p>咨询过网管，他们也在查找原因．可以确定，他们没改任何配置和参数，近来也没有增添任何新设备过改动</p>

<p>猜测原因：
&ndash; 1.外网的问题．这个排除，因为其它本地方，没有网络问题的报告
&ndash; 2.内部有主机干扰主干路由器，中病毒或者其它．这个可能性也不大，如果是干扰路由器，那样网管会很快查找出原因．也不可能会访问得到网络
&ndash; 3.路由器可能运行异常．网管尝试过重启路由器，但问题仍在
&ndash; 4.线路断了．</p>

<hr />

<h5>问题解决</h5>

<p>其实这个问题应该很明显了，就是第四个原因．但当时很傻的认为，既然可以访问网络，只是速度慢了，所以线路，比如网线／电缆／光纤什么的，一定是通畅无误的，否则不是慢的问题，而是能不能上网的问题．但岂知，问题就出现在此</p>

<p>最后问题确定出现在核心交换机的六对光纤中的一对出了问题造成的，通过问题光纤的数据包会丢失，导致出现选择性的丢包现象.当时为什么没想到，是线路部分断了，这样就会丢包，于是会不停的确认和连接，这样又出现在主干网路中，当大家访问多了，这种现象就更严重了．</p>

<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git常用命令]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/16/git/"/>
    <updated>2014-07-16T19:27:13+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/16/git</id>
    <content type="html"><![CDATA[<h4>Git常用命令</h4>

<p>Git命令很多，大多都可直接用git查询，有些用不上．常用的也就那几条，记录之．</p>

<!--more-->


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git diff/git diff --cached/git diff HEAD
</span><span class='line'>git add -u 将本地改动的文件add
</span><span class='line'>git add -A
</span><span class='line'>git mv file1 file2
</span><span class='line'>git add .
</span><span class='line'>git commit -m'a'
</span><span class='line'>git push origin source
</span><span class='line'>git reset --hard HEAD^/HEAD^^/HEAD~100
</span><span class='line'>git reset -hard ****
</span><span class='line'>git log / git log --pretty=oneline
</span><span class='line'>git reflog 
</span><span class='line'>git status
</span><span class='line'>
</span><span class='line'>working directory工作区---&gt;版本库repository{stage/index暂存区, master};
</span><span class='line'>
</span><span class='line'>git checkout --　file 丢弃工作区的修改，回到和暂存区一致
</span><span class='line'>git reset　HEAD filename撤销暂存区中的修改，表示filename是最新的版本
</span><span class='line'>误删rm文件后，可以git checkout -- file
</span><span class='line'>git rm file从版本库中删除，再git commit -m''或者rm file后再git rm file 再git commit -m''
</span><span class='line'>
</span><span class='line'>本地仓库添加远程库git remote add origin url 远程库名叫origin
</span><span class='line'>git push -u origin master(第一次推送)
</span><span class='line'>git push orighin master
</span><span class='line'>
</span><span class='line'>主分支master，提倡用分支来完成工作，再合并后删除
</span><span class='line'>创建分支git checkout -b dev(b表示创建并切换)相当于git branch dev 和git checkout dev
</span><span class='line'>git branch查看当前分支
</span><span class='line'>git checkout master切回分支
</span><span class='line'>git merge dev合并分支到master上
</span><span class='line'>git branch -d dev 删除分支
</span><span class='line'>
</span><span class='line'>git merge --no-ff -m"" dev合并分支时禁用fast forward方式，这样分支的commit信息还会存在
</span><span class='line'>
</span><span class='line'>git stash把当前工作现场储存起来
</span><span class='line'>git stash list查看工作现场
</span><span class='line'>git stash apply恢复，但stash内容不删除，需要git stash drop删除
</span><span class='line'>git stash pop恢复并删除stash
</span><span class='line'>git remote　－v 查看远程信息
</span><span class='line'>git branch -D branchname强行删除分支
</span><span class='line'>git push origin master推送分支master到远程
</span><span class='line'>git pull把远程的提交抓下来，然后本地合并，解决冲突后再推送上去
</span><span class='line'>一般分支master, dev, bug, featurejjj
</span><span class='line'>git checkout -b dev origin/dev本地创建dev分支
</span><span class='line'>git tag v1.0打标签
</span><span class='line'>git tag查看tags
</span><span class='line'>git tag name commitid -m'a'
</span><span class='line'>git tag -d name 删除
</span><span class='line'>git push origin name 推送某个
</span><span class='line'>git psuh origin --tags推送所有
</span><span class='line'>
</span><span class='line'>github上的pull　request申请后才可以pull上去
</span><span class='line'>fork也可以pull
</span><span class='line'>创建.gitignore文件，把要忽略的文件名放进去git会忽略
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Exponentiation]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/16/exponentiation/"/>
    <updated>2014-07-16T10:49:34+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/16/exponentiation</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程之美|数字之迷]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/16/bian-cheng-zhi-mei-%7Cshu-zi-zhi-mi/"/>
    <updated>2014-07-16T10:30:05+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/16/bian-cheng-zhi-mei-|shu-zi-zhi-mi</id>
    <content type="html"><![CDATA[<h4>编程之美之数学之迷</h4>

<p>此书趣味多多．前者类似题充斥网络，始作者即此书也．可见其影响之广，流传之远．细看年月，已数年之久，可谓经典．求职者奉为圭臬，学生党视若珍宝，今一睹真容．</p>

<!--more-->


<p><strong>目录：</strong>
&ndash;  <a href="#1">2.1 二进制中1的个数</a>
&ndash;  <a href="#2">2.2 阶乘</a>
&ndash;  <a href="#3">2.3 发帖水王</a>
&ndash;  <a href="#4">2.4 1的数目</a>
&ndash;  <a href="#5">2.5 最大的k个数目</a>
&ndash;  <a href="#6">2.6 精确表达浮点数</a>
&ndash;  <a href="#7">2.7 最大公约数</a>
&ndash;  <a href="#8">2.8 符合条件的整数</a></p>

<h5 id="1">2.1二进制中1的个数</h5>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Google_c++编程规范图]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/15/google-c-plus-plus-bian-cheng-gui-fan-tu/"/>
    <updated>2014-07-15T02:30:11+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/15/google-c-plus-plus-bian-cheng-gui-fan-tu</id>
    <content type="html"><![CDATA[<h5>Google C++ Style Guide</h5>

<p>觅得神图一张，尽解Google C++ Style Guide</p>

<p>制作精美，详尽得当，不可多得</p>

<p>感谢原作者<a href="http://blog.csdn.net/voidccc/article/details/37599203">voidccc</a></p>

<!--more-->


<p><strong>原图（可另存）</strong></p>

<p><img src="http://mkdir1.github.io/images/google_c++.png"></p>

<h5>总结一下</h5>

<ul>
<li><ol>
<li>文件名小写，可有下划线或短线，扩展为.cc</li>
</ol>
</li>
<li><ol>
<li>开关加版权，许可证，作者，说明．．</li>
</ol>
</li>
<li><ol>
<li>.h文件顺序：本类的.h，C系统文件，C++系统文件，其它库，本项目头文件，避免用../.开关，要绝对路径指示.h</li>
</ol>
</li>
<li><ol>
<li>禁止使用using namespace xx,而用using std::string</li>
</ol>
</li>
</ul>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome快捷键]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/15/chromekuai-jie-jian/"/>
    <updated>2014-07-15T00:39:34+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/15/chromekuai-jie-jian</id>
    <content type="html"><![CDATA[<h4>chrome下的快捷键&amp;Vimium</h4>

<p>chrome算是自己常用的浏览器之一吧，一直是键盘党，就算是chrome仍用vimium这种vim插件．对于程序员来说，用鼠标是可耻的，不到万不得已，也不能用．</p>

<p>所以烂熟快捷键可谓高手之于心法，工欲善其事，必先利其器，信然～</p>

<!--more-->


<h5>快捷键大全</h5>

<p>下者所列乃大部常用操作，</p>

<p><strong>常用特注之</strong></p>

<p><strong>Chrome窗口和标签页快捷键</strong></p>

<ul>
<li><strong>Ctrl+N</strong> 打开新窗口</li>
<li><strong>Ctrl+T</strong> 打开新标签页</li>
<li>Ctrl+Shift+N 在隐身模式下打开新窗口</li>
<li>Ctrl+O，选择文件 在谷歌浏览器中打开计算机上的文件</li>
<li>按住 Ctrl 键，然后点击链接 从后台在新标签页中打开链接，但您仍停留在当前标签页中</li>
<li>按住 Ctrl+Shift 键，然后点击链接 在新标签页中打开链接，同时切换到新打开的标签页</li>
<li>按住 Shift 键，然后点击链接 在新窗口中打开链接</li>
<li><strong>Alt+F4</strong> 关闭当前窗口</li>
<li><strong>Ctrl+Shift+T</strong> 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</li>
<li>将链接拖动到标签页内 在指定标签页中打开链接</li>
<li>将链接拖动到两个标签页之间 在标签页横条的指定位置建立一个新标签页，在该标签页中打开链接</li>
<li>Ctrl+1 到 Ctrl+8 切换到指定位置编号的标签页。您按下的数字代表标签页横条上的相应标签位置。</li>
<li>Ctrl+9 切换到最后一个标签页</li>
<li><strong>Ctrl+Tab 或 Ctrl+PgDown</strong> 切换到下一个标签页,这里和vimium中的H功能一样，不过都要记住</li>
<li><strong>Ctrl+Shift+Tab 或 Ctrl+PgUp</strong> 切换到上一个标签页，vimium下的L</li>
<li><strong>Ctrl+W 或 Ctrl+F4</strong> 关闭当前标签页或弹出式窗口</li>
<li><strong>Alt+Home</strong> 打开主页</li>
</ul>


<p><strong>Chrome地址栏快捷键</strong></p>

<ul>
<li>键入搜索字词 使用默认搜索引擎进行搜索</li>
<li>键入网址中”www.”和”.com”之间的部分，然后按Ctrl+Enter 键 为您在地址栏中输入的内容添加”www.”和”.com”，然后打开网址</li>
<li>键入搜索引擎关键字或网址，按 Tab键，然后键入搜索字词 使用与关键字或网址相关联的搜索引擎进行搜索。如果谷歌浏览器可以识别您要使用的搜索引擎，则会提示您按 Tab 键。</li>
<li>F6 或 Ctrl+L 或 Alt+D 选中网址区域中的内容</li>
<li>键入网址，然后按 Alt+Enter 键 在新标签页中打开网址</li>
<li>打开谷歌chrome浏览器各功能的快捷键</li>
<li><strong>Ctrl+B</strong> 打开和关闭书签栏</li>
<li><strong>Ctrl+Shift+B</strong> 打开书签管理器</li>
<li><strong>Ctrl+H</strong> 查看”历史记录”页</li>
<li><strong>Ctrl+J</strong> 查看”下载”页</li>
<li>Shift+Escape 查看任务管理器</li>
<li>Shift+Alt+T 将焦点设置在工具栏上。使用键盘上的向右和向左箭头，可导航至工具栏上的不同按钮。</li>
</ul>


<p><strong>Chrome网页快捷键</strong></p>

<ul>
<li>Ctrl+P 打印当前页</li>
<li>Ctrl+S 保存当前页</li>
<li>F5 重新加载当前页</li>
<li>Esc 停止加载当前页</li>
<li>Ctrl+F 打开”在网页上查找”框</li>
<li>点击鼠标中键或滚轮（只在谷歌浏览器测试版（只有英文版）中可用） 激活自动滚动。当您移动鼠标时，网页会根据鼠标的移动方向自动滚动。</li>
<li>Ctrl+F5 或 Shift+F5 重新加载当前页，但忽略缓存内容</li>
<li>按住 Alt 键，然后点击链接 下载链接</li>
<li><strong>Ctrl+G 或 F3</strong> 查找与您在”在网页上查找”框中输入的内容相匹配的下一个匹配项</li>
<li>Ctrl+Shift+G 或 Shift+F3 查找与您在”在网页上查找”框中输入的内容相匹配的上一个匹配项</li>
<li><strong>Ctrl+U</strong> 查看源代码</li>
<li>将链接拖动到书签栏 将链接加入书签</li>
<li><strong>Ctrl+D</strong> 将当前网页加入书签</li>
<li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮 放大网页上的所有内容</li>
<li>Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮 缩小网页上的所有内容</li>
<li>Ctrl+0 将网页上的所有内容都恢复到正常大小</li>
<li>选中内容，然后按 Ctrl+C 键 将内容复制到剪贴板</li>
<li>将光标置于文本字段中，然后按 Ctrl+V 或 Shift+Insert 键 从剪贴板粘贴当前内容</li>
<li>将光标置于文本字段中，然后按 <strong>Ctrl+Shift+V</strong> 键 从剪贴板粘贴当前内容的纯文本部分</li>
<li>选中文字字段中的内容，然后按 Ctrl+X 或Shift+Delete 键 删除内容并将其复制到剪贴板</li>
</ul>


<hr />

<h4>Vimium下的快捷键</h4>

<p>与chrome算是绝配，有如虎添翼之感．Geek神器，大神必备</p>

<ul>
<li>j: 向下移动。</li>
<li>k：向上移动。（不明白默认的表示是啥用法，使用了c-y这三个键没有效果）</li>
<li>h：向左移动。</li>
<li>l：向右移动。</li>
<li>zH：一直移动到左部。</li>
<li>zL:一直移动到右部。</li>
<li>gg：跳转到页面的顶部。</li>
<li>G：跳转到页面的底部。</li>
<li><strong>d：向下翻页</strong>（相当于PageDown被按下了）</li>
<li><strong>u：向上翻页</strong>（相当于PageUp被按下了）</li>
<li>r：重新载入该页（相当于F5刷新页面）</li>
<li><strong>gs：查看页面源代码</strong> 等于chrome下的Ctrl+U</li>
<li><strong>yy：拷贝当前页面的URL到剪贴板</strong>当前页面</li>
<li>yf：拷贝某一个URL到剪贴板（实际上是相当于输入了f，然后出现很多编码的URL，选择某个之后，相当于拷贝了某个，因为一个页面中可能有很多超链接）</li>
<li><strong>gu：跳转到父页面</strong>（比如<a href="http://www.douban.com/group/vim/%EF%BC%8C%E8%BE%93%E5%85%A5%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8D%B3http://www.douban.com/group/%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BA%8EH%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%AF%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2%EF%BC%89">http://www.douban.com/group/vim/%EF%BC%8C%E8%BE%93%E5%85%A5%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8D%B3http://www.douban.com/group/%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BA%8EH%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%AF%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2%EF%BC%89</a></li>
<li>i：输入模式（如果发现命令不起作用，可能是进入输入模式了，此时按Esc回到命令模式）</li>
<li><strong>gi：将焦点集中到第一个输入框</strong>（输入gNi则焦点集中到第N个输入框）</li>
<li>f：在当前的页面打开一个新的链接。</li>
<li>F：在新的页面打开一个新的链接。</li>
<li>:在当前页面打开多个链接（没感觉使用到了多个标签，不过表示的是输入af）</li>
<li><strong>b：在当前页打开一个书签</strong>。（输入部分网址会自动进行搜索）</li>
<li><strong>B：在新的标签页打开一个书签</strong></li>
<li>gf：循环到当前页面的下一个框层（可能跟页面制作有关，目前没用到）</li>
<li>/ : 查找</li>
<li>n: 向下查找匹配内容</li>
<li>N：向上查找匹配内容</li>
<li><strong>H：回退上一个历史页面（相当于浏览器中的向左箭头）Ctrl+Tab或者Ctrl+PageDown</strong></li>
<li><strong>L：回到下一个历史页面（相当于浏览器的向右箭头）</strong></li>
<li><strong>K，gt：跳转到右边的一个标签页</strong></li>
<li><strong>J，gT：跳转到左边的一个标签页</strong> 和chrome下的Ctrl+9一样．</li>
<li>t：创建一个新的标签页</li>
<li><strong>x：关闭当前的标签页</strong> = Ctrl+W</li>
<li><strong>X：恢复刚刚关闭的标签页</strong> = Ctrl+Shift+T</li>
<li><strong>？：显示命令的帮助提示（再按一次关闭）</strong></li>
</ul>


<hr />

<p>还有一些通用的快捷键：</p>

<ul>
<li>空格</li>
<li>PageUp, PageDown, Array</li>
<li>Home, End, Insert</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ssh无密码登录]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/15/sshwu-mi-ma-deng-lu/"/>
    <updated>2014-07-15T00:30:04+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/15/sshwu-mi-ma-deng-lu</id>
    <content type="html"><![CDATA[<h4>ssh无密码登录</h4>

<!--more-->


<p>ssh应用太广，最常用的就是远程登录和文件传输了，每次输入密码和登录确实很浪费时间，这里就不需要输入密码了</p>

<h5>设置</h5>

<ul>
<li><ol>
<li>在客户端．生成密钥<code>ssh-keygen -t rsa</code>，这样在~/.ssh文件夹中就会有一个公钥和一个私钥</li>
</ol>
</li>
<li><ol>
<li>服务端，在~/.ssh中，将客户端的id_rsa.phb放到这里，<code>scp .ssh/id_rsa.phb ip:.ssh/authorizend_keys</code>，也可以命名其它的</li>
</ol>
</li>
<li><ol>
<li>再登录时就可以不用输入密码．也可以把登录alias写入bash中，scp时也不用输入密码，但是还是要记住ip</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sed入门]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/14/sedru-men/"/>
    <updated>2014-07-14T21:26:23+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/14/sedru-men</id>
    <content type="html"><![CDATA[<h4>Sed入门</h4>

<p>sed &ndash; stream editor for filtering and transforming text</p>

<p>sed是非交互式编辑器，很强大．掌握了将得心应手．命令很简单，关键是熟练运用．入门也很简单．估计一个小时内就了解了</p>

<!--more-->


<h5>特点</h5>

<ul>
<li>1.sed不会修改文件</li>
<li>2.默认所有的输出行都被打印到屏幕上.具体是读入一行到缓冲区，处理这一行，发送到屏幕，删除缓冲区内容，处理下一行</li>
<li><ol>
<li>sed [选项]&hellip; {脚本(如果没有其他脚本)} [输入文件]&hellip;</li>
</ol>
</li>
<li><ol>
<li>sed不管是否找到指定的模式，它的退出状态都是0。只有当命令存在语法错误时，sed的退出状态才不是0</li>
</ol>
</li>
</ul>


<h5>命令和选项</h5>

<table>
<thead>
<tr>
<th>命令　    </th>
<th> 解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>a\        </td>
<td>在当前行后添加一行或多行。多行时除最后一行外，每行末尾需用“\”续行</td>
</tr>
<tr>
<td> c\ </td>
<td> 用此符号后的新文本替换当前行中的文本。多行时除最后一行外，每行末尾需用&#8221;\&ldquo;续行</td>
</tr>
<tr>
<td> i\ </td>
<td> 在当前行之前插入文本。多行时除最后一行外，每行末尾需用&#8221;\&ldquo;续行</td>
</tr>
<tr>
<td> d  </td>
<td> 删除行</td>
</tr>
<tr>
<td> h  </td>
<td> 把模式空间里的内容复制到暂存缓冲区</td>
</tr>
<tr>
<td> H  </td>
<td> 把模式空间里的内容追加到暂存缓冲区</td>
</tr>
<tr>
<td> g  </td>
<td> 把暂存缓冲区里的内容复制到模式空间，覆盖原有的内容</td>
</tr>
<tr>
<td> G  </td>
<td> 把暂存缓冲区的内容追加到模式空间里，追加在原有内容的后面</td>
</tr>
<tr>
<td> l  </td>
<td> 列出非打印字符</td>
</tr>
<tr>
<td> p  </td>
<td> 打印行</td>
</tr>
<tr>
<td> n  </td>
<td> 读入下一输入行，并从下一条命令而不是第一条命令开始对其的处理</td>
</tr>
<tr>
<td> q  </td>
<td> 结束或退出sed</td>
</tr>
<tr>
<td> r  </td>
<td> 从文件中读取输入行</td>
</tr>
<tr>
<td> !  </td>
<td> 对所选行以外的所有行应用命令</td>
</tr>
<tr>
<td> s  </td>
<td> 用一个字符串替换另一个</td>
</tr>
<tr>
<td> g  </td>
<td> 在行内进行全局替换</td>
</tr>
<tr>
<td> w  </td>
<td> 将所选的行写入文件</td>
</tr>
<tr>
<td> x  </td>
<td> 交换暂存缓冲区与模式空间的内容</td>
</tr>
<tr>
<td> y  </td>
<td> 将字符替换为另一字符（不能对正则表达式使用y命令）</td>
</tr>
<tr>
<td> -e </td>
<td>    进行多项编辑，即对输入行应用多条sed命令时使用</td>
</tr>
<tr>
<td> -n </td>
<td>   取消默认的输出</td>
</tr>
<tr>
<td> -f </td>
<td>  指定sed脚本的文件名</td>
</tr>
</tbody>
</table>


<h5>正则表达式</h5>

<p>**正则表达式要括在斜杠线&#8221;/&ldquo;之间.如果要把正则表达式分隔符&rdquo;/&ldquo;改为另一个字符，比如o，则&rdquo;\o..o&#8221;,例如：sed -n &lsquo;\o<sup>Myop</sup>&rsquo; datafile</p>

<table>
<thead>
<tr>
<th>元字符   </th>
<th> 功能            </th>
<th>   示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>^ </td>
<td> 行首定位符 </td>
<td> /^my/  匹配所有以my开头的行</td>
</tr>
<tr>
<td>$  </td>
<td>   行尾定位符 </td>
<td> /my$/  匹配所有以my结尾的行</td>
</tr>
<tr>
<td>.  </td>
<td>  匹配除换行符以外的单个字符 </td>
<td> /m..y/  匹配包含字母m，后跟两个任意字符，再跟字母y的行</td>
</tr>
<tr>
<td>*  </td>
<td> 匹配零个或多个前导字符 </td>
<td> /my*/  匹配包含字母m,后跟零个或多个y字母的行</td>
</tr>
<tr>
<td>[] </td>
<td>匹配指定字符组内的任一字符 </td>
<td> /[Mm]y/  匹配包含My或my的行</td>
</tr>
<tr>
<td>[^]</td>
<td>匹配不在指定字符组内的任一字符</td>
<td>/[^Mm]y/  匹配包含y，但y之前的那个字符不是M或m的行</td>
</tr>
<tr>
<td> (..)</td>
<td>   保存已匹配的字符 </td>
<td>   1,20s/(you)self/\1r/  标记元字符之间的模式，并将其保存为标签1，之后可以使用\1来引用它。最多可以定义9个标签，从左边开始编号，最左边的是第一个。此例中，对第1到第20行进行处理，you被保存为标签1，如果发现youself，则替换为your。</td>
</tr>
<tr>
<td>&amp; </td>
<td>保存查找串以便在替换串中引用</td>
<td>s/my/<strong>&amp;</strong>/  符号&amp;代表查找串。my将被替换为<strong>my</strong></td>
</tr>
<tr>
<td>&lt;</td>
<td>词首定位符 </td>
<td> /&lt;my/  匹配包含以my开头的单词的行</td>
</tr>
<tr>
<td>></td>
<td>词尾定位符</td>
<td>/my>/|  匹配包含以my结尾的单词的行</td>
</tr>
<tr>
<td>x{m}</td>
<td>连续m个x</td>
<td>/9{5}/ 匹配包含连续5个9的行</td>
</tr>
<tr>
<td>x{m,}</td>
<td>至少m个x</td>
<td>/9{5,}/  匹配包含至少连续5个9的行</td>
</tr>
<tr>
<td>x{m,n}</td>
<td>至少m个，但不超过n个x</td>
<td>/9{5,7}/  匹配包含连续5到7个9的行</td>
</tr>
</tbody>
</table>


<h5>示例</h5>

<pre><code>sed '2,5d' file删除2到5行
sed '/My/,/You/d' file 删除包含My的和到包含You之间的行
sed '$d' file删除最后一行，其余的打印
sed '/my/p' file把所有行打印一次，再把包含my的行打印一次
sed -n '/my/p' file -n取消了默认打印，只打印匹配项
sed 's/^my/you/g' file 替换my为you,g表示所有的都替换
sed -n '2,20s/my$/you/gp' file 替换，并只打印替换的行，上一个会默认全打印
sed -e '1,100d' -e 's/a/b/g' file多重编辑
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最系列]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/"/>
    <updated>2014-07-13T19:58:08+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie</id>
    <content type="html"><![CDATA[<h4>最系列</h4>

<p>常见到最长子序列，最长公共子序列等，网上总结了也很多．但自己实现一次方才了解．发现收获很多的．</p>

<h4>目录</h4>

<ul>
<li>1.<a href="#1">最长公共子序列</a></li>
<li>2.<a href="#2">最长公共子串</a></li>
<li>3.<a href="#3">最长重复子串</a></li>
<li>4.<a href="#4">最长回文子串</a></li>
<li>5.<a href="#5">最大递增子序列</a></li>
<li>6.<a href="#6">最大子数组和</a></li>
<li>7.<a href="#7">最大M子段和</a></li>
<li>8.<a href="#8">最大和子矩阵</a></li>
<li>9.<a href="#9">字符串编码距离</a></li>
<li>10.<a href="#10">最长不重复子串</a></li>
</ul>


<!--more-->




<h5 id="1">最长公开子序列</h5>


<p>这个最基础，动态规划；转移方程:</p>

<p>C[i,j] = 0; 初始</p>

<p>C[i,j] = C[i-1,j-1] + 1; Xi = Yi</p>

<p>C[i,j] = max(C[i-1,j], C[i,j-1]); Xi != Yi;</p>

<p>**代码</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int LCS(char *str1, char *str2, int m, int n, int len[][100],int sub[][100])
{
        int i,j;
        for(i=0;i&lt;m;i++)
            len[i][0] = 0;
        for(i=0;i&lt;n;i++)
            len[0][i] = 0;
        for(i=1;i&lt;=m;i++)
        for(j=1;j&lt;=n;j++)
        {
            if(str1[i-1]==str2[j-1])
            {
                len[i][j] = len[i-1][j-1] + 1;
                sub[i][j] = 0;
            }
            else if(len[i-1][j]&gt;=len[i][j-1])
            {
                len[i][j] = len[i-1][j];
                sub[i][j] = 1;
            }
            else
            {
                len[i][j] = len[i][j-1];
                sub[i][j] = -1;
            }
        }
        return len[m][n];
}

void PrintSub(char *x,int i, int j, int b[][100])
{
    if(i==0||j==0)
        return;
    if(b[i][j] == 0)
    {
        PrintSub(x,i-1,j-1,b);
        printf("%c",x[i-1]);
    }
    else if(b[i][j]==1)
        PrintSub(x,i-1,j,b);
    else 
        PrintSub(x,i,j-1,b);
    return ;
}
int main()
{
    char str1[100],str2[100];
    int len1,len2;
    int subq[100][100],subq_len[100][100]; 
    while(~scanf("%s %s",str1,str2))
    {
        len1 = strlen(str1); 
        len2 = strlen(str2); 
        int len = LCS(str1,str2,len1,len2,subq_len,subq);
        printf("%d\n",len);
        PrintSub(str1,len1,len2,subq);
        printf("\n");
    }
    return 0;
}
</code></pre>

<h5 id="2">最长公开子串</h5>


<p>串和序列的区别在于连续与否，两者实现也差不多</p>

<p>**代码</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int LCS(char *str1, char *str2, int m, int n, char *str3, int len[][100])
{
        int i,j;
        int max = -1;
        int x,y;
        int k;
        for(i=0;i&lt;m;i++)
            len[i][0] = 0;
        for(i=0;i&lt;n;i++)
            len[0][i] = 0;
        for(i=1;i&lt;=m;i++)
        for(j=1;j&lt;=n;j++)
        {
            if(str1[i-1]==str2[j-1])
                len[i][j] = len[i-1][j-1] + 1;
            else 
                len[i][j] = 0;
            if(len[i][j]&gt;max)
            {
                max = len[i][j];
                x = i;
                y = j;
            }
        }
        k = max;
        str3[k] = '\0';
        while(k&gt;=0)
            str3[--k] = str1[--x];
        return max;
}

int main()
{
    char str1[100],str2[100];
    char str3[100];
    int len1,len2;
    int subq_len[100][100]; 
    while(~scanf("%s %s",str1,str2))
    {
        len1 = strlen(str1); 
        len2 = strlen(str2); 
        int len = LCS(str1,str2,len1,len2,str3,subq_len);
        printf("%s\n",str3);
        printf("%d\n",len);
    }
    return 0;
}
</code></pre>

<h5 id="6">最大子数组和</h5>


<p>即一个数组中连续元素和的最大值，如1,2,-4,2 最大是3</p>

<p>**代码:　</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main()
{
    int n, a[100];
    int i,sum,tmp;
    int maxsum ;
    while(~scanf("%d",&amp;n))
    {
        maxsum = INT_MIN;
        sum = tmp = 0;
        for(i=0;i&lt;n;i++)
        {
            scanf("%d",&amp;a[i]);
            tmp += a[i];
            if(tmp&lt;0)
                tmp = 0;
            else
                sum = tmp;
            if(sum&gt;maxsum)
                maxsum = sum;
        }
        if(maxsum&lt;=0)
        {
            maxsum = a[0];
            for(i=0;i&lt;n;i++)
                if(a[i]&gt;maxsum)
                    maxsum = a[i];
        }
        printf("%d\n",maxsum);
    }
    return 0;
}
</code></pre>

<h5 id="5">最大子数组</h5>


<p>序列可以为数组，也可以为特别的结构体，原理应该是一样的
**代码：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//return the length
int LongIncreaseSubsquence1(int *a, int n, int *b)
{
    int i,j;
    int lenght = 1;
    if(n&lt;=0)return 0;
    if(n==1)return 1;
    b[0] = 1;
    for(i=1;i&lt;n;i++)
    {
        b[i] = 1;
        for(j=0;j&lt;i;j++)
        {
            if(a[j]&lt;a[i]&amp;&amp;b[j]+1&gt;b[i])
               b[i] = b[j] + 1;
        }
    }
    for(i=1;i&lt;n;i++)
        lenght = (lenght&gt;=b[i]?lenght:b[i]);
    return lenght;
}
int main()
{
    int a[100];
    int b[100];
    int n,i;
    while(~scanf("%d",&amp;n))
    {
        for(i=0;i&lt;n;i++)
            scanf("%d",&amp;a[i]);
        int len = LongIncreaseSubsquence1(a,n,b);
        printf("%d\n",len);
    }
    return 0;
}
</code></pre>

<p>还有两种方法：
&ndash; 1.基于最长公共子序列，先把原串排序，再求最长公共子序列
&ndash; 2.再查找b[n]的时候，用二分法，因为b[n]是递增的序列</p>

<hr />

<h5>最大各子矩阵</h5>

<h5>最长重复子串</h5>

<h5>最长回文子串</h5>

<h5>最大M子段</h5>

<h5 id="9">字符编码距离</h5>


<p>两个字符串，从其中一个变为另外一个需要的操作次数就是编码距离，这个或者还有其它的名词称谓．</p>

<p>操作只有三种最基本的，即增删改，例如abc和bcd的距离就是，abc删除a，再后面添加d，操作就两步</p>

<p>这种有一个很简单的方法，基于最长公共子序列，首先求出最长公共子序列int len = GetLongestCommomSubsquence(str1,str2),然后得到两个字符串长度，len1,len2.则操作的距离是len1+len2-len*2</p>

<p>当这几个系列的操作都了解后，好多字符串的处理都是基于此的</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    int minDistance(string word1, string word2) {
</span><span class='line'>        // Start typing your C/C++ solution below
</span><span class='line'>        // DO NOT write int main() function
</span><span class='line'>        int row = word1.length() + 1;
</span><span class='line'>        int col = word2.length() + 1;
</span><span class='line'>        
</span><span class='line'>        vector&lt;vector&lt;int&gt; &gt; f(row, vector&lt;int&gt;(col));
</span><span class='line'>
</span><span class='line'>        for (int i = 0; i &lt; row; i++)
</span><span class='line'>            f[i][0] = i;
</span><span class='line'>
</span><span class='line'>        for (int i = 0; i &lt; col; i++)
</span><span class='line'>            f[0][i] = i; 
</span><span class='line'>        for (int i = 1; i &lt; row; i++)
</span><span class='line'>            for (int j = 1; j &lt; col; j++){
</span><span class='line'>                if (word1[i-1] == word2[j-1])
</span><span class='line'>                    f[i][j] = f[i-1][j-1];
</span><span class='line'>                else
</span><span class='line'>                    f[i][j] = f[i-1][j-1] + 1;
</span><span class='line'>                f[i][j] = min(f[i][j], min(f[i-1][j]+1, f[i][j-1]+1));
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>        return f[row-1][col-1];
</span><span class='line'>    }
</span><span class='line'>};lass Solution {
</span><span class='line'>public:
</span><span class='line'>    int minDistance(string word1, string word2) {
</span><span class='line'>        // Start typing your C/C++ solution below
</span><span class='line'>        // DO NOT write int main() function
</span><span class='line'>        int row = word1.length() + 1;
</span><span class='line'>        int col = word2.length() + 1;
</span><span class='line'>        
</span><span class='line'>        vector&lt;vector&lt;int&gt; &gt; f(row, vector&lt;int&gt;(col));
</span><span class='line'>
</span><span class='line'>        for (int i = 0; i &lt; row; i++)
</span><span class='line'>            f[i][0] = i;
</span><span class='line'>
</span><span class='line'>        for (int i = 0; i &lt; col; i++)
</span><span class='line'>            f[0][i] = i;
</span><span class='line'>
</span><span class='line'>        for (int i = 1; i &lt; row; i++)
</span><span class='line'>            for (int j = 1; j &lt; col; j++){
</span><span class='line'>                if (word1[i-1] == word2[j-1])
</span><span class='line'>                    f[i][j] = f[i-1][j-1];
</span><span class='line'>                else
</span><span class='line'>                    f[i][j] = f[i-1][j-1] + 1;
</span><span class='line'>                f[i][j] = min(f[i][j], min(f[i-1][j]+1, f[i][j-1]+1));
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>        return f[row-1][col-1];
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<hr />

<p><strong><em>待续</em></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[星月神话]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/13/xing-yue-shen-hua/"/>
    <updated>2014-07-13T16:03:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/13/xing-yue-shen-hua</id>
    <content type="html"><![CDATA[<h4>星月神话</h4>

<!--more-->


<p>参加葬礼一出．当地习俗，传承日久，势必请法师做法，戏子唱戏，乐队奏乐．亲朋来吊，乡里致哀，伤感不已．出殡之日，更是凝重无比．</p>

<p>古人有云：死生亦大矣．千古同此一叹．原本哀事，古人忌讳死，故曰喜．曰白喜事．</p>

<p>葬礼按部就班．唯乐队一曲＂<strong>星月神话</strong>＂，曲调哀婉，绵延幽长．旋律和缓，饱含感伤．虽原词歌诵爱情，流行已久，但于此处尤撩人伤怀，其音高于鞭炮礼花齐鸣，抑扬顿挫之调引人回忆．笛声悠扬，琴声绵长，更增凝重．曲调层层递进，情感步步难抑～</p>

<p><strong>＂千年之后的你会在哪里？身边有怎样风景＂</strong>．到此，几欲落泪.</p>

<hr />

<p><strong>星月神话，金莎</strong>(点击欣赏)</p>

<p>  <audio controls="controls">
  <source src="http://mkdir1.github.io/music/xing.mp3" type="audio/mpeg">
  </audio></p>

<pre><code>作词:金莎 作曲:金莎

我的一生最美好的场景
就是遇见你
在人海茫茫中静静凝望着你
陌生又熟悉

尽管呼吸着同一天空的气息
却无法拥抱到你
如果转换了时空身份和姓名
但愿认得你眼睛

千年之后的你会在哪里
身边有怎样风景
我们的故事并不算美丽
却如此难以忘记

尽管呼吸着同一天空的气息
却无法拥抱到你
如果转换了时空身份和姓名
但愿认得你眼睛

千年之后的你会在哪里
身边有怎样风景
我们的故事并不算美丽
却如此难以忘记

如果当初勇敢的在一起
会不会不同结局
你会不会也有千言万语
埋在沉默的梦里
</code></pre>

<hr />

<p>感时伤怀之作甚多，生离死别之事不少．屏幕电视演绎者再．若不经历生死，不目睹死别，诚不知容颜易老，韶华难再．俱各为前程，东奔西走，行色匆匆，始知相聚甚难. 纵为亲子，如之奈何？若抚遗像嗟悼，徒留回忆，岂不痛哉！</p>

<p>活在当下，珍惜眼前吧!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Software for Blog on Ubuntu]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/12/software-for-blog-on-ubuntu/"/>
    <updated>2014-07-12T22:14:15+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/12/software-for-blog-on-ubuntu</id>
    <content type="html"><![CDATA[<h3>写博客常用到的工具</h3>

<p>磨刀不费砍柴功，看来工具真的很重要</p>

<p>今天网上又发现一些好东西</p>

<!--more-->


<h4>常用快捷键</h4>

<p>那些我知道的就不列了哈，找些实用但不常用的</p>

<ul>
<li><ol>
<li>C+Super+D</li>
</ol>
</li>
<li><ol>
<li>C+H 资源管理器中显示隐藏文件</li>
</ol>
</li>
<li><ol>
<li><strong>Alt+PrtSc截取窗口; Shift+PrtSc部分截取</strong>，这个比qq上的截取功能相似，很强大</li>
</ol>
</li>
<li><ol>
<li>Super+w 显示当前所有窗口，专业术语Expo模式</li>
</ol>
</li>
<li><ol>
<li>Super+S 缩小工作区，相当于点击了工作区的按键</li>
</ol>
</li>
<li><ol>
<li>Alt+F2弹出命令窗口，相当于Windows下的Win+R</li>
</ol>
</li>
<li><ol>
<li>Alt+Tab与Alt+｀一起使用，效果很酷</li>
</ol>
</li>
</ul>


<hr />

<h4>software</h4>

<ul>
<li><p>1.图片处理，mypaint,shotwell和gthumb. 前者是自带的，直接命令行下可用.都是ap-get install 就可得到的.设置好软件，可命令行启动.</p></li>
<li><ol>
<li>feedly查看rss的利器，但本人习惯用thunderbird. 主要是集成了邮件和rss，相对方便．　可以把feedly中获取非技术类的文章，有空的时候打开看看．　毕竟thunderbird太过臃肿，东西太多</li>
</ol>
</li>
<li><ol>
<li>Google Docs.编辑文档的很多，wps等，但是，一般我们要的是轻量级的编辑工具，而不是启动慢，工具选项多，操作不便的，大而全的工具．当然对于博客来说</li>
</ol>
</li>
<li><ol>
<li>Sublime 以后非命令行下，可以试试这个</li>
</ol>
</li>
<li><ol>
<li>Eclipse, Vim, Qt Creator, Sublime.各有一批拥趸．适合不同的开发者．Sublime适合前端，Vim通用，其它的集成，也很广泛</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Love-Letter Mystery]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/11/the-love-letter-mystery/"/>
    <updated>2014-07-11T14:55:48+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/11/the-love-letter-mystery</id>
    <content type="html"><![CDATA[<h4><a href="https://www.hackerrank.com/challenges/the-love-letter-mystery">The Love-Letter Mystery</a></h4>

<hr />

<p>James got hold of a love letter that his friend Harry has written for his girlfriend. Being the prankster that James is, he decides to meddle with it. He changes all the words in the letter into palindromes.</p>

<p>While modifying the letters of the word, he follows 2 rules:</p>

<p>(a) He always reduces the value of a letter, e.g. he changes &rsquo;d&#8217; to &lsquo;c&rsquo;, but he does not change &lsquo;c&rsquo; to &rsquo;d&#8217;.
(b) If he has to repeatedly reduce the value of a letter, he can do it until the letter becomes &lsquo;a&rsquo;. Once a letter has been changed to &lsquo;a&rsquo;, it can no longer be changed.</p>

<p>Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations he carries out to convert a given string into a palindrome.</p>

<!--more-->


<p>Input Format</p>

<p>The first line contains an integer T, i.e., the number of test cases.
The next T lines will contain a string each.</p>

<p>Output Format</p>

<p>A single line containing the number of minimum operations corresponding to each test case.</p>

<p>Constraints</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 ≤ T ≤ 10
</span><span class='line'>1 ≤ length of string ≤ 104 
</span><span class='line'>All characters are lower cased english letters.</span></code></pre></td></tr></table></div></figure>


<p>Sample Input #00</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3
</span><span class='line'>abc
</span><span class='line'>abcba
</span><span class='line'>abcd</span></code></pre></td></tr></table></div></figure>


<p>Sample Output #00</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2
</span><span class='line'>0
</span><span class='line'>4</span></code></pre></td></tr></table></div></figure>


<p>Explanation</p>

<p>For the first test case, ab<em>c</em> &ndash;> ab<em>b</em> &ndash;> ab<em>a</em>.
For the second test case, abcba is a palindromic string.
For the third test case, abc<em>d</em> &ndash;> abc<em>c</em> &ndash;> abc<em>b</em> &ndash;> abc<em>a</em> = ab<em>c</em>a &ndash;> ab<em>b</em>a.</p>

<hr />

<p>**The Code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

int main()
{
    int T,sum,j,diff;
    char str[10000];
    while(cin&gt;&gt;T)
        {
        for(int i=0;i&lt;T;i++)
            {
            cin&gt;&gt;str;
            int len = strlen(str);
            len -=1;
            sum = 0;
            j = 0;
            while(j&lt;len)
                {
                str[j]&gt;str[len]?diff=str[j]-str[len]:diff=str[len]-str[j];
                sum += diff;
                j++;
                len--;
            }
            cout&lt;&lt;sum&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>

<p><audio controls="controls">
  <source src="http://mkdir1.github.io/music/xing.mp3" type="audio/mpeg">
</audio></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gem-stones]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/11/gem-stones/"/>
    <updated>2014-07-11T14:38:44+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/11/gem-stones</id>
    <content type="html"><![CDATA[<h3><a href="https://www.hackerrank.com/challenges/gem-stones">Gem-stones</a></h3>

<p>John has discovered various rocks. Each rock is composed of various elements, and each element is represented by a lowercase latin letter from &lsquo;a&rsquo; to &lsquo;z&rsquo;. An element can be present multiple times in a rock. An element is called a &lsquo;gem-element&rsquo; if it occurs at least once in each of the rocks.</p>

<p>Given the list of rocks with their compositions, display the number of gem-elements that exist in those rocks.</p>

<!--more-->


<ul>
<li>Input Format</li>
</ul>


<p>The first line consists of N, the number of rocks.
Each of the next N lines contain rocks&#8217; composition. Each composition consists of lowercase letters of English alphabet.</p>

<ul>
<li>Output Format</li>
</ul>


<p>Print the number gem-elements that exist in those rocks.</p>

<p>Constraints</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>1 ≤ N ≤ 100 
</span><span class='line'>Each composition consists of only small latin letters ('a'-'z'). 
</span><span class='line'>1 ≤ Length of each composition ≤ 100</span></code></pre></td></tr></table></div></figure>


<p>Sample Input</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>3
</span><span class='line'>abcdde
</span><span class='line'>baccd
</span><span class='line'>eeabg</span></code></pre></td></tr></table></div></figure>


<p>Sample Output</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>2</span></code></pre></td></tr></table></div></figure>


<p>Explanation
Only &ldquo;a&rdquo;, &ldquo;b&rdquo; are the two kind of gem-elements, since these are the only characters that occur in each of the rocks&#8217; composition.</p>

<hr />

<p><strong>The Code</strong>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

int main()
{
    int N;
    int ele[26];
    char str[100];
    while(cin&gt;&gt;N)
    {
        int sum = 0;
        for(int i=0;i&lt;26;i++)ele[i]=1;
        for(int i=0;i&lt;N;i++)
        {
            cin&gt;&gt;str;
            int len = strlen(str);
            for(int j=0;j&lt;len;j++)
                if(ele[str[j]-'a']!=0)
                ele[str[j]-'a']++;
            for(int k=0;k&lt;26;k++)
            {        
                if(ele[k]&gt;1)
                    ele[k]=1;
                else
                    ele[k]=0;
            } 
        } 
        for(int j=0;j&lt;26;j++)
                if(ele[j]==1)sum++;

           printf("%d\n",sum);
        }

    return 0;    
}

---
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown转html和pdf]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/10/markdownzhuan-htmlhe-pdf/"/>
    <updated>2014-07-10T17:59:21+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/10/markdownzhuan-htmlhe-pdf</id>
    <content type="html"><![CDATA[<h3>Markdown转html和pdf</h3>

<p>这个功能很实用，可以在网上完成．但对于本地，则也有几个不错的工具选择</p>

<hr />

<!--more-->


<h4>之前的解决方案</h4>

<p>可以在这几个网址上完成转换:</p>

<ul>
<li><p>1 <a href="http://maxiang.info/">马克飞象</a>,这个很方便，可以同步evernote，b也有不错的界面，是目前我最看好的一个．但唯一不爽的是保存的pdf中竟然有它的logo这个真是要命</p></li>
<li><p>2 <a href="https://stackedit.io/">statedit</a>,这个也不错，和前者很像．应该大部分这类网站都是这个风格，在没有搭建好本地的转换的时候，本人一直是在这上面完成pdf转换的，想来真是折腾啊</p></li>
<li><p>3 再一个就是linux下的retext了，这是个简单的免费工具，文本操作，对于vim程序员确实使用不爽，唯一的用处就是预览和修改用</p></li>
<li><p>4 还好，linux下面有一个markdown的命令，使用也简单，也<code>sudo apt-get isntall markdwon</code>就行.不过令人不爽的是，html乱码，对中文支持不够，看了官网上的，好像还是2004年的更新，所以一定有我这样的志士仁人受不了</p></li>
</ul>


<hr />

<h5>现在的解决方案</h5>

<p>程序员的原则就是大道至简，其实就是方便，通俗点就是懒惰，怎么能忍受如此多的工具换来换去的，那岂不是要疯，最好是一个命令就搞定，生成了pdf, txt, html, md等所有格式，如果要用，就直接里面找．</p>

<p>首先安装<code>sudo apt-get install pandoc</code>，再看下它的方法，使用也很简单</p>

<p><strong>语法如下</strong></p>

<pre><code>pandoc -h
pandoc [OPTIONS] [FILES]
Input formats:  native, markdown, markdown+lhs, rst, rst+lhs, html, latex, latex+lhs
Output formats:  native, html, html+lhs, s5, docbook, opendocument, odt, latex, latex+lhs, context, texinfo, man, markdown, markdown+lhs, plain, rst, rst+lhs, mediawiki, rtf
Options:
  -f FORMAT, -r FORMAT  --from=FORMAT, --read=FORMAT                    
  -t FORMAT, -w FORMAT  --to=FORMAT, --write=FORMAT                     
  -s                    --standalone                                    
  -o FILENAME           --output=FILENAME                               
  -p                    --preserve-tabs                                 
                        --tab-stop=TABSTOP                              
                        --strict                                        
                        --reference-links                               
  -R                    --parse-raw                                     
  -S                    --smart                                         
  -m[URL]               --latexmathml[=URL], --asciimathml[=URL]        
                        --mathml[=URL]                                  
                        --mimetex[=URL]                                 
                        --jsmath[=URL]                                  
                        --gladtex                                       
  -i                    --incremental                                   
                        --xetex                                         
  -N                    --number-sections                               
                        --no-wrap                                       
                        --sanitize-html                                 
                        --email-obfuscation=none|javascript|references  
                        --id-prefix=STRING                              
                        --indented-code-classes=STRING                  
                        --toc, --table-of-contents                      
                        --base-header-level=LEVEL                       
                        --template=FILENAME                             
  -V FILENAME           --variable=FILENAME                             
  -c URL                --css=URL                                       
  -H FILENAME           --include-in-header=FILENAME                    
  -B FILENAME           --include-before-body=FILENAME                  
  -A FILENAME           --include-after-body=FILENAME                   
  -C FILENAME           --custom-header=FILENAME                        
  -T STRING             --title-prefix=STRING                           
                        --reference-odt=FILENAME                        
  -D FORMAT             --print-default-template=FORMAT                 
                        --data-dir=DIRECTORY                            
                        --dump-args                                     
                        --ignore-args                                   
  -v                    --version                                       
  -h                    --help
</code></pre>

<p>支持格式中，比较有用的有**markdown, html, latex, rtf, odt</p>

<h4>使用</h4>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pandoc -f markdown -t html -o example.html example.md
</span><span class='line'>pandoc --ascii example.md -o example.html
</span><span class='line'>    </span></code></pre></td></tr></table></div></figure>


<p>加&mdash;ascii后html不会乱码</p>

<h4>转为pdf</h4>

<p>这个历程真是坑，转为pdf的软件何其多，当初很2的选择了xhtml2pdf.这个软件我至今还没安装好，依赖包好多，PIL, Reporlab．最后安装好了，还是出问题．当时的想法就是换一个软件．终于有一个神器出现了</p>

<pre><code>sudo apt-get install unoconv
</code></pre>

<p>使用也很方便，<code>unoconv -f pdf demo.html</code></p>

<p>为什么说<strong>unoconv</strong>是神器了，用了才知道它支持好多格式，常用的几乎包含了．</p>

<h4>写个Makefile就好了</h4>

<pre><code>MD = pandoc
MDFLAGS = --ascii
H2P = unoconv
H2PFLAGS = -f pdf 
SOURCES := $(wildcard *.md)
OBJECTS := $(patsubst %.md, %.html, $(wildcard *.md))
OBJECTS_PDF := $(patsubst %.md, %.pdf, $(wildcard *.md))
all: build
build: html pdf
pdf: $(OBJECTS_PDF)
html: $(OBJECTS)
$(OBJECTS_PDF): %.pdf: %.html
    $(H2P) $(H2PFLAGS) $&lt; 
$(OBJECTS): %.html: %.md
    $(MD) $(MDFLAGS) -o $@ $&lt;
clean:
    rm -f $(OBJECTS) *.pdf
</code></pre>

<p>这样再直接用就一切ok</p>

<h4>写个Shell一切安好</h4>

<p>这里整理一下要点</p>

<ul>
<li><ol>
<li>查找匹配后缀名<code>find * -type f -name '*.md'</code>，这里如果find后是.则匹配的文件有本目录如，./demo.md，如果用*则如demo.md</li>
</ol>
</li>
<li><p>2.匹配文件名和后缀，如果file=&ldquo;thisfile.md&rdquo;,则${file%.<em>}表示thisfile, ${file##</em>.}表示md</p></li>
</ul>


<p><strong>详细代码，我的shell名为tran.sh</strong></p>

<pre><code>#!/bin/sh                                                          
filelist=`find * -type f -name '*.md'`
for file in $filelist
do   
    htmlfile=${file%.*}.html
    pandoc --ascii $file -o $htmlfile
    unoconv -f pdf $htmlfile
done 
</code></pre>

<p>最后就放到bin中就搞定了</p>

<p>有的后缀很花样，没办法，把shell中两行改为:</p>

<pre><code>filelists=`find * -type f -name '*.markdown'`
for file in $filelist $filelists
</code></pre>

<p>Enjoy~</p>
]]></content>
  </entry>
  
</feed>
