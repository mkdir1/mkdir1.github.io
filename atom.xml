<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-25T17:46:10+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Thunderbird下的muttator插件]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/25/thunderbirdxia-de-muttatorcha-jian/"/>
    <updated>2014-07-25T17:00:58+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/25/thunderbirdxia-de-muttatorcha-jian</id>
    <content type="html"><![CDATA[<h4>Thunderbird下的muttator</h4>

<p>在linux下工作，Thunderbird应该不可或缺．但是对于追求极简主义的人来说，用鼠标就是一种耻辱，简直就是浪费生命．虽然在chrome下有vimium，firefox下有vimperator，但是对于Thunderbird这一常见的应用，怎么可能没有一个与之匹配的神器呢？于是<br/>
Muttator横空出世．</p>

<!--more-->


<hr />

<h5>功能</h5>

<p>这就不必介绍了，大多数类vim插件，大同小异．记住不同点反而成了某个插件的特点了</p>

<p>需要注意的几点：</p>

<ol>
<li>在邮件中，用Ctrl+n/p上下选邮件列表中的项</li>
<li>Rss订阅中的每一篇文章，用vim上下切换</li>
<li>针对每一具体文章或者邮件，也是vim键操作</li>
<li>在这三个选项中切换用m来切，比如，从2切到3,用m,3到2用esc切</li>
<li>记几个常用的thunderbird快捷键:

<ul>
<li>F6面板切换</li>
<li>Ctro+o退出
　　- F5接受所有消息
　　- Ctrl++/&mdash;放大缩小
　　- F回复邮件，hint功能</li>
</ul>
</li>
<li>其它功能有特发掘</li>
</ol>


<hr />
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM 重定向]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/25/acm-zhong-ding-xiang/"/>
    <updated>2014-07-25T09:07:06+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/25/acm-zhong-ding-xiang</id>
    <content type="html"><![CDATA[<h4>ACM输入输出重定向</h4>

<p>问题描述：<br/>
在做ACM题时，对于输入输出，总需要键盘来操作，这样显然不方向，对于多数据的测试，显然不合理，现有一个实用的重定向函数，可很好解决.</p>

<!--more-->


<h5>解决</h5>

<p>首先，gcc中有一个－D选项，这样表示在文件中添加宏定义</p>

<pre><code>gcc -o example example.c -D TAG
</code></pre>

<p>在正文中添加</p>

<pre><code>#ifndef TAG
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt+", stdout);
#endif
</code></pre>

<p>这样，就直接可以重定向到两个文件中．</p>

<p>包含在<code>#include&lt;stdio.h&gt;</code>中</p>

<hr />

<h5>另外</h5>

<p>在windows下找到一个解决方案，有bat文件中<code>example.exe&lt;input.txt&gt;output.txt</code> 不过，一般有IDE中就解决了，不必这么麻烦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[编程名言名句]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/24/bian-cheng-ming-yan-ming-ju/"/>
    <updated>2014-07-24T16:25:05+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/24/bian-cheng-ming-yan-ming-ju</id>
    <content type="html"><![CDATA[<h4>编程名言</h4>

<!--more-->


<p>UNIX 很简单。但需要有一定天赋的人才能理解这种简单。 Dennis Ritchie</p>

<p>软件在能够复用前必须先能用。
　　–Ralph Johnson</p>

<p>优秀的判断力来自经验，但经验来自于错误的判断。
　　–Fred Brooks</p>

<p>‘理论’是你知道是这样，但它却不好用。‘实践’是它很好用，但你不知道是为什么。程序员将理论和实践结合到一起：既不好用，也不知道是为什么。
　　–佚名</p>

<p>当你想在你的代码中找到一个错误时，这很难；当你认为你的代码是不会有错误时，这就更难了。
　　-Steve McConnell 《代码大全》</p>

<p>如果建筑工人盖房子的方式跟程序员写程序一样，那第一只飞来的啄木鸟就将毁掉人类文明。
　　-Gerald Weinberg</p>

<p>项目开发的六个阶段：</p>

<p>充满热情</p>

<p>醒悟</p>

<p>痛苦</p>

<p>找出罪魁祸首</p>

<p>惩罚无辜</p>

<p>褒奖闲人</p>

<p>　　–佚名</p>

<p>优秀的代码是它自己最好的文档。当你考虑要添加一个注释时，问问自己，“如何能改进这段代码，以让它不需要注释？”</p>

<p>　　-Steve McConnell 《代码大全》</p>

<p>我们这个世界的一个问题是，蠢人信誓旦旦，智人满腹狐疑。</p>

<p>　　–Bertrand Russell</p>

<p>无论在排练中演示是如何的顺利(高效)，当面对真正的现场观众时，出现错误的可能性跟在场观看的人数成正比。</p>

<p>　　–佚名</p>

<p>罗马帝国崩溃的一个主要原因是，没有0，他们没有有效的方法表示他们的C程序成功的终止。</p>

<p>　　–Robert Firth</p>

<p>C程序员永远不会灭亡。他们只是 cast 成了 void。</p>

<p>　　–佚名</p>

<p>如果 debugging 是一种消灭 bug 的过程，那编程就一定是把 bug 放进去的过程。</p>

<p>　　–Edsger Dijkstra</p>

<p>你要么要软件质量，要么要指针算法；两者不可兼得。</p>

<p>(Bertrand Meyer)</p>

<p>有两种方法能写出没有错误的程序；但只有第三种好用。
–Alan J. Perlis</p>

<p>用代码行数来测评软件开发进度，就相对于用重量来计算飞机建造进度。
–比尔-盖茨</p>

<p>最初的 90% 的代码用去了最初 90% 的开发时间。余下的 10% 的代码用掉另外 90% 的开发时间。
–Tom Cargill</p>

<p>程序员和上帝打赌要开发出更大更好——傻瓜都会用的软件。而上帝却总能创造出更大更傻的傻瓜。所以，上帝总能赢。
–Anon</p>

<p>Talk is cheap, show me your code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cheat-sheet for Programmer]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/24/cheat-sheet-for-programmer/"/>
    <updated>2014-07-24T16:09:01+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/24/cheat-sheet-for-programmer</id>
    <content type="html"><![CDATA[<h4>useful cheat sheet for programmer</h4>

<p>I found a very useful sheets for programmer. Including almost everyaspects.</p>

<p>Here is the <a href="http://yuncode.net/article/a_5348e54c880e945">LINK</a></p>

<p>Thanks to the author.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shell终端快捷键]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/23/shellzhong-duan-kuai-jie-jian/"/>
    <updated>2014-07-23T09:52:32+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/23/shellzhong-duan-kuai-jie-jian</id>
    <content type="html"><![CDATA[<h4>Shell下的快捷操作</h4>

<!--more-->


<p>黑色为常用的操作</p>

<p><strong>ctrl + d</strong>      删除光标所在位置上的字符相当于VIM里x或者dl</p>

<p>ctrl + h      删除光标所在位置前的字符相当于VIM里hx或者dh</p>

<p><strong>ctrl + k</strong>      删除光标后面所有字符相当于VIM里d shift+$</p>

<p><strong>ctrl + u</strong>      删除光标前面所有字符相当于VIM里d shift+^</p>

<p><strong>ctrl + w</strong>     删除光标前一个单词相当于VIM里db</p>

<p><strong>ctrl + y</strong>      恢复ctrl+u上次执行时删除的字符</p>

<p>ctrl + ?      撤消前一次输入</p>

<p>alt  + r      撤消前一次动作</p>

<p>alt  + d     删除光标所在位置的后单词</p>

<p>移动</p>

<p><strong>ctrl + a</strong>     将光标移动到命令行开头相当于VIM里shift+^</p>

<p><strong>ctrl + e</strong>     将光标移动到命令行结尾处相当于VIM里shift+$</p>

<p><strong>ctrl + f</strong>      光标向后移动一个字符相当于VIM里l</p>

<p><strong>ctrl + b</strong>     光标向前移动一个字符相当于VIM里h</p>

<p>ctrl + 方向键左键    光标移动到前一个单词开头</p>

<p>ctrl + 方向键右键    光标移动到后一个单词结尾</p>

<p><strong>ctrl + x</strong>       在上次光标所在字符和当前光标所在字符之间跳转</p>

<p>alt  + f      跳到光标所在位置单词尾部</p>

<p>替换</p>

<p><strong>ctrl + t</strong>       将光标当前字符与前面一个字符替换</p>

<p>alt  + t     交换两个光标当前所处位置单词和光标前一个单词</p>

<p>alt  + u     把光标当前位置单词变为大写</p>

<p>alt  + l      把光标当前位置单词变为小写</p>

<p>alt  + c      把光标当前位置单词头一个字母变为大写</p>

<p><strong>^oldstr ^newstr</strong>    替换前一次命令中字符串</p>

<p>历史命令编辑</p>

<p><strong>ctrl + p</strong>   返回上一次输入命令字符</p>

<p><strong>ctrl + r</strong>       输入单词搜索历史命令</p>

<p><strong>alt  + p</strong>     输入字符查找与字符相接近的历史命令</p>

<p>alt  + >     返回上一次执行命令</p>

<p>其它</p>

<p><strong>ctrl + s</strong>      锁住终端，貌似有些shell不可用</p>

<p><strong>ctrl + q</strong>      解锁终端</p>

<p><strong>ctrl + l</strong>        清屏相当于命令clear</p>

<p>ctrl + c       另起一行</p>

<p><strong>ctrl + i</strong>       类似TAB健补全功能</p>

<p>ctrl + o      重复执行命令</p>

<p>alt  + 数字键  操作的次数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向对象的5个基本原则]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/23/mian-xiang-dui-xiang-de-5ge-ji-ben-yuan-ze/"/>
    <updated>2014-07-23T09:20:56+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/23/mian-xiang-dui-xiang-de-5ge-ji-ben-yuan-ze</id>
    <content type="html"><![CDATA[<h4>面向对象的5个基本原则</h4>

<p>1、单一职责原则</p>

<p>一个类只做一件事</p>

<p>2、开放封闭原则</p>

<p>可扩展但还是不可修改</p>

<p>3、替换原则</p>

<p>子类替换父类</p>

<p>4、依赖倒置原则</p>

<p>高层不依赖低层</p>

<p>5、接口隔离原则</p>

<p>小接口代大接口</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debug工具]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/debuggong-ju/"/>
    <updated>2014-07-22T22:05:47+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/debuggong-ju</id>
    <content type="html"><![CDATA[<h4>Debug工具</h4>

<p>看到一内存调试工具，貌似很厉害，老夫居然前所未闻，今试之，感觉博大精深．</p>

<p>Valgrind, 用于内存测试，内存泄漏等，支持众多平台</p>

<!--more-->


<p>Debug绝对是和Code一样重要的技能，现在掌握的Debug技能真是乏善可陈，说来惭愧，之前在写一个驱动的时候，一直用的是printf类似的提示，可见见识浅短．</p>

<p>当然，GDB是常用的神器，功能强大</p>

<p>还有C中不注意的一处，宏：</p>

<p><strong>FILE</strong></p>

<p><strong>LINE</strong></p>

<p><strong>FUNC</strong></p>

<p>现记录一下，以后更新&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sudoku-solver]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/sudoku-solver/"/>
    <updated>2014-07-22T20:27:47+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/sudoku-solver</id>
    <content type="html"><![CDATA[<h4>Sudoku Solver</h4>

<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>Empty cells are indicated by the character &lsquo;.&rsquo;.</p>

<p>You may assume that there will be only one unique solution.</p>

<!--more-->


<p>递归的方法，确实不错～　</p>

<h5>Code</h5>

<pre><code>bool isValid(vector&lt;vector&lt;char&gt; &gt; &amp;board, int a, int b) {
        int i,j;
        for(i = 0; i &lt; 9; i++)
            if(i != a &amp;&amp; board[i][b] == board[a][b])
                return false;

        for(j = 0; j &lt; 9; j++)
            if(j != b &amp;&amp; board[a][j] == board[a][b])
                return false;

        int x = a/3*3;
        int y = b/3*3;
        for(i = 0; i &lt; 3; i++)
            for(j = 0; j&lt; 3; j++)
                if(x+i != a &amp;&amp; y+j != b &amp;&amp; board[x+i][y+j] == board[a][b])
                    return false;
        return true;
    }
    bool solveSudokudfs(vector&lt;vector&lt;char&gt; &gt; &amp;board)
    {
        for(int i = 0; i &lt; 9; i++)
            for(int j = 0; j &lt; 9; j++)
            {
                if(board[i][j] == '.')
                {
                    for(int k = 1; k &lt;= 9; k++)
                    {
                        board[i][j] = '0' + k;
                        if(isValid(board,i,j) &amp;&amp; solveSudokudfs(board))
                            return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        return true;
    }
    void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) {
        // Note: The Solution object is instantiated only once.
        solveSudokudfs(board);
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid-sudoku]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/valid-sudoku/"/>
    <updated>2014-07-22T19:56:41+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/valid-sudoku</id>
    <content type="html"><![CDATA[<h4>Valid Sudoku</h4>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character &lsquo;.&rsquo;.</p>

<p>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>

<p>我这解法，绝对是对算法的侮辱～　哈哈</p>

<!--more-->


<p>Code:</p>

<pre><code>class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) 
    {
        for(int i=0;i&lt;9;i++)
        for(int j=0;j&lt;9;j++)
        {
            if(board[i][j]=='.')
                continue;
            for(int k=j+1;k&lt;9;k++)
                if(board[i][j]==board[i][k])return false;
            for(int k=i+1;k&lt;9;k++)
                if(board[i][j]==board[k][j])return false;
            if(i%3==0&amp;&amp;j%3==0)
            {
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
                if(board[i+2][j+1]!='.'&amp;&amp;board[i+2][j+1]==board[i][j])return false;
                if(board[i+1][j+2]!='.'&amp;&amp;board[i+1][j+2]==board[i][j])return false;
                if(board[i+2][j+2]!='.'&amp;&amp;board[i+2][j+2]==board[i][j])return false;
            }
            if(i%3==0&amp;&amp;(j-1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+2][j-1]!='.'&amp;&amp;board[i+2][j-1]==board[i][j])return false;
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
                if(board[i+2][j+1]!='.'&amp;&amp;board[i+2][j+1]==board[i][j])return false;   
            }
            if(i%3==0&amp;&amp;(j+1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+2][j-1]!='.'&amp;&amp;board[i+2][j-1]==board[i][j])return false;
                if(board[i+1][j-2]!='.'&amp;&amp;board[i+1][j-2]==board[i][j])return false;
                if(board[i+2][j-2]!='.'&amp;&amp;board[i+2][j-2]==board[i][j])return false;   
            }
            if((i-1)%3==0&amp;&amp;j%3==0)
            {
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
                if(board[i+1][j+2]!='.'&amp;&amp;board[i+1][j+2]==board[i][j])return false;
            }
            if((i-1)%3==0&amp;&amp;(j-1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
            }
             if((i-1)%3==0&amp;&amp;(j+1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+1][j-2]!='.'&amp;&amp;board[i+1][j-2]==board[i][j])return false;
            }

        }
        return true;
    }
};
</code></pre>

<p>好吧，管用就行，一遍过需要多仔细认真啊</p>

<p>这样代码还是很好看的，就是有点长</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode-combination Sum]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/leetcode-combination-sum/"/>
    <updated>2014-07-22T17:05:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/leetcode-combination-sum</id>
    <content type="html"><![CDATA[<h4>Combination Sum</h4>

<p>Given a set of candidate numbers &copy; and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>

<p>The same repeated number may be chosen from C unlimited number of times.</p>

<p>Note:</p>

<p>All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</p>

<p>The solution set must not contain duplicate combinations.
For example, given candidate set 2,3,6,7 and target 7,
A solution set is:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[2,3,6,7] 7
</span><span class='line'>[7] 
</span><span class='line'>[2, 2, 3] 
</span></code></pre></td></tr></table></div></figure>


<!--more-->


<p>这题真是基础，之前一直对此类不知所措，现在略通一二，甚喜</p>

<p>Code:</p>

<pre><code>class Solution {
public:
    void Getcom(vector&lt;int&gt;&amp;can, int target, vector&lt;vector&lt;int&gt;&gt;&amp;result, int level, int &amp;sumcurrent, int nsize, vector&lt;int&gt;&amp;tmp)
    {
        if(sumcurrent&gt;target)return;
        if(target==sumcurrent)
        {
            result.push_back(tmp);
            return;
        }
        for(int i=level;i&lt;nsize;i++)
        {

                sumcurrent += can[i];
                tmp.push_back(can[i]);
                Getcom(can,target,result,i,sumcurrent,nsize,tmp);
                tmp.pop_back();
                sumcurrent -=can[i];
        }

    }
    vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) 
    {
       vector&lt;vector&lt;int&gt;&gt; result;
       vector&lt;int&gt;tmp;
       int size = candidates.size();
       sort(candidates.begin(),candidates.end());
       int sumc = 0;
       Getcom(candidates,target,result,0,sumc,size,tmp);
       return result;
    }
};
</code></pre>

<p>DFS方便记录结果，DP方便记数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP入门]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/20/phpru-men/"/>
    <updated>2014-07-20T13:18:28+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/20/phpru-men</id>
    <content type="html"><![CDATA[<h4>PHP入门</h4>

<p>前端的几门语言，HTML/CSS/JavaScript/XML等，这些语言有很大的关联性，很多都是相通相互使用的．入门后，至少可以阅读源码，这样对理解和布局帮助很大．</p>

<p>至于高级技巧和应用，如果从事前端的开发，那就要精通了，这里只对本人初学入门所用，仅对基本语法和代码阅读无碍即可．</p>

<!--more-->


<h5>介绍与特点</h5>

<ul>
<li>1.PHP脚本是在服务器上执行</li>
<li>2.PHP Hypertext Preprocessor</li>
<li>3.开源脚本语言，可免费下载，相对于微软的ASP，其是收费的，</li>
<li>4.PHP文件能包含文本，HTML, CSS以及PHP代码</li>
<li>5.PHP在服务器上运行，结果以纯文本返回浏览器</li>
<li><ol>
<li>PHP文件后缀.php</li>
</ol>
</li>
</ul>


<h5>PHP能够做什么　</h5>

<ul>
<li>1.PHP 能够生成动态页面内容</li>
<li>2.PHP 能够创建、打开、读取、写入、删除以及关闭服务器上的文件</li>
<li>3.PHP 能够接收表单数据</li>
<li>4.PHP 能够发送并取回 cookies</li>
<li>5.PHP 能够添加、删除、修改数据库中的数据</li>
<li>6.PHP 能够限制用户访问网站中的某些页面</li>
<li>7.PHP 能够对数据进行加密</li>
<li>8.通过 PHP，您可以不受限于只输出 HTML。您还能够输出图像、PDF 文件、甚至 Flash 影片。您也可以输出任何文本，比如 XHTML 和 XML</li>
<li>9.LAMP中的P就是PHP</li>
</ul>


<h5>安装PHP</h5>

<ul>
<li><ol>
<li>安装Web服务器，LAMP中的Apatch</li>
</ol>
</li>
<li><ol>
<li>安装数据库，Mysql</li>
</ol>
</li>
<li><ol>
<li>安装PHP</li>
</ol>
</li>
</ul>


<p>如需在 Windows 平台设置并立即运行 PHP，您还可以安装<strong>WebMatrix</strong>.</p>

<p>WebMatrix is a free, lightweight, cloud-connected web development tool</p>

<h5>基本语法</h5>

<ul>
<li>1.PHP脚本以<code>&lt;?php　//代码　．．　?&gt;</code>包含起来</li>
<li>2.PHP文件通常包含HTML标签和PHP脚本代码</li>
<li>3.PHP代码中语句以;结尾</li>
<li>4,注释// # /**/</li>
<li>5.大小写敏感</li>
<li>6.有点像Shell脚本</li>
</ul>


<p>变量规则：
&ndash;  变量以 $ 符号开头，其后是变量的名称
&ndash;  变量名称必须以字母或下划线开头
&ndash;  变量名称不能以数字开头
&ndash;  变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）
&ndash;  变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）</p>

<p>三种不同作用域变量：
&ndash; local（局部）
&ndash; global（全局）
&ndash; static（静态）</p>

<p>通常，当函数完成/执行后，会删除所有变量。不过，有时我需要不删除某个局部变量。实现这一点需要更进一步的工作。
要完成这一点，请在您首次声明变量时使用 static</p>

<p>echo 和 print 之间的差异：
&ndash; echo &ndash; 能够输出一个以上的字符串
&ndash; print &ndash; 只能输出一个字符串，并始终返回 1
&ndash; 两者均可包含括号</p>

<p><strong>数据类型:</strong>字符串、整数、浮点数、逻辑、数组、对象、NULL</p>

<p><strong>整数规则：</strong>
&ndash; 整数必须有至少一个数字（0-9）
&ndash; 整数不能包含逗号或空格
&ndash; 整数不能有小数点
&ndash; 整数正负均可
&ndash; 可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）</p>

<p>浮点数是有小数点或指数形式的数字</p>

<p>逻辑是 true 或 false</p>

<p>对象是存储数据和有关如何处理数据的信息的数据类型。
在 PHP 中，必须明确地声明对象。
首先我们必须声明对象的类。对此，我们使用 class 关键词。类是包含属性和方法的结构。
然后我们在对象类中定义数据类型，然后在该类的实例中使用</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>class Car
</span><span class='line'>{
</span><span class='line'>  var $color;
</span><span class='line'>  function Car($color="green") {
</span><span class='line'>    $this-&gt;color = $color;
</span><span class='line'>  }
</span><span class='line'>  function what_color() {
</span><span class='line'>    return $this-&gt;color;
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p><strong>字符串函数</strong>
&ndash; strle()
&ndash; strpos();查找匹配字符，strpos(&ldquo;Hello&rdquo;,&ldquo;ll&rdquo;);结果为2;找不到返回FALSE</p>

<p><a href="http://www.w3school.com.cn/php/php_ref_string.asp">参考字符串函数</a></p>

<p>define()函数定义常量</p>

<p><strong>运算符</strong>
. 串接，如$str1=&ldquo;hello&rdquo;;$str2=$str1.&ldquo;world&rdquo;;则str=&ldquo;helloworld&rdquo;;
.= 串接赋值</p>

<p>还有条件语句，循环，数组等，这一些操作和其它语句有很大的相似，可直接读代码时得到什么意思，但于自己写的话，可能需要常期训练．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xml学习]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/20/xmlxue-xi/"/>
    <updated>2014-07-20T04:13:30+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/20/xmlxue-xi</id>
    <content type="html"><![CDATA[<h4>XML入门</h4>

<p>XML用来传输和存储数据</p>

<p>HTML用来显示数据</p>

<p>Extensible Markup Language可扩展标记语言，类似HTML也是标记语言</p>

<!--more-->


<h5>特点</h5>

<ul>
<li>1.XML标签没有预定义，HTML标签定义了</li>
<li>2.XML被设计用来结构化，存储以及传输信息</li>
<li>3.Json也是和XML功能相同，但用的范围不同</li>
<li>4.XML是纯文本，没有什么特别之处，可以处理文本的软件都可来处理XML</li>
<li>5.XML 是独立于软件和硬件的信息传输工具</li>
<li>6.XML把数据从HTML中分离</li>
<li>7.XML 简化数据共享</li>
<li>8.XML 简化数据传输</li>
<li>9.XHTML &ndash; 最新的 HTML 版本</li>
<li>10.WSDL &ndash; 用于描述可用的 web service</li>
<li>11.WAP 和 WML &ndash; 用于手持设备的标记语言</li>
<li>12.RSS &ndash; 用于 RSS feed 的语言</li>
<li>13.RDF 和 OWL &ndash; 用于描述资源和本体</li>
<li>14.SMIL &ndash; 用于描述针针对 web 的多媒体</li>
</ul>


<h5>语法</h5>

<p>第一行一般为说明文字
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;ISO-8859-1&rdquo;?></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;
</span><span class='line'>&lt;note&gt;
</span><span class='line'>&lt;to&gt;George&lt;/to&gt;
</span><span class='line'>&lt;from&gt;John&lt;/from&gt;
</span><span class='line'>&lt;heading&gt;Reminder&lt;/heading&gt;
</span><span class='line'>&lt;body&gt;Don't forget the meeting!&lt;/body&gt;
</span><span class='line'>&lt;/note&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li>第一行，说明文字</li>
<li>第二行，根部，note是自定义文字，note说明是个书签</li>
<li>第三行，to的内容是George，对应的其它行意义一样</li>
</ul>


<h5>树形结构</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;root&gt;
</span><span class='line'>    &lt;child&gt;
</span><span class='line'>        &lt;subchild&gt;...&lt;/subchild&gt;
</span><span class='line'>    &lt;/child
</span><span class='line'>    &lt;otherchild&gt;...&lt;/otherchild&gt;
</span><span class='line'>&lt;/root&gt;</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>1.还可以像HTML那样添加属性</p></li>
<li><p>2.元素必须有关闭标签</p></li>
<li><p>3.对大小写敏感</p></li>
<li><p>4.必须正确嵌套</p></li>
</ul>


<p>这是最基础的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android-控件]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/19/android-kong-jian/"/>
    <updated>2014-07-19T21:00:37+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/19/android-kong-jian</id>
    <content type="html"><![CDATA[<h4>Android常用控件</h4>

<p>仅列常用的控件，并实践之．毕竟初学者，学会用，有印象即可，其它的可举一反三，融会贯通．</p>

<!--more-->


<h5>TextView</h5>

<h5>EditText</h5>

<h5>ImageView</h5>

<h5>Button</h5>

<h4>#</h4>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring/"/>
    <updated>2014-07-18T21:22:53+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h5><a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a></h5>

<h5>Probles</h5>

<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>

<p>看本站内的总结：<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最长回文字符串</a></p>

<!--more-->


<h5>Code</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    string longestPalindrome(string s)
</span><span class='line'>    {
</span><span class='line'>        int len = s.length();
</span><span class='line'>        string str="";
</span><span class='line'>        if(len==0)return str;
</span><span class='line'>        int maxlen = 0;
</span><span class='line'>        int leng;
</span><span class='line'>        int left,right;
</span><span class='line'>        for(int i=0;i&lt;2*len-1;i++)
</span><span class='line'>        {
</span><span class='line'>            if(i%2==0)
</span><span class='line'>            {
</span><span class='line'>                leng = 1;
</span><span class='line'>                left = i/2 - 1;
</span><span class='line'>                right = i/2 + 1;
</span><span class='line'>                while(left&gt;=0&&right&lt;len&&s.at(left)==s.at(right))
</span><span class='line'>                {
</span><span class='line'>                    leng += 2;
</span><span class='line'>                    left--;
</span><span class='line'>                    right++;
</span><span class='line'>                }
</span><span class='line'>                 if(leng&gt;maxlen)
</span><span class='line'>              {
</span><span class='line'>                    maxlen = leng;
</span><span class='line'>                    str = s.substr(i/2-maxlen/2, maxlen);
</span><span class='line'>              }
</span><span class='line'>            }
</span><span class='line'>            else
</span><span class='line'>            {
</span><span class='line'>                leng = 0;
</span><span class='line'>                left = i/2;
</span><span class='line'>                right = i/2+1;
</span><span class='line'>                 while(left&gt;=0&&right&lt;len&&s[left]==s[right])
</span><span class='line'>                {
</span><span class='line'>                    leng += 2;
</span><span class='line'>                    left--;
</span><span class='line'>                    right++;
</span><span class='line'>                }
</span><span class='line'>               
</span><span class='line'>            
</span><span class='line'>             if(leng&gt;maxlen)
</span><span class='line'>              {
</span><span class='line'>                    maxlen = leng;
</span><span class='line'>                    str = s.substr(i/2-maxlen/2+1, maxlen);
</span><span class='line'>              }
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>        return str;
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<h5>注意</h5>

<ul>
<li><ol>
<li>把奇偶统一起来，这样i的大小是2len-1的大小</li>
</ol>
</li>
<li><ol>
<li>还有一个注意点是，substr()这个两个参数是指起始和长度，起始从0开始就算第一个</li>
</ol>
</li>
<li><ol>
<li>后面两个if判断不能统一起来，因为substr中的参数不一样</li>
</ol>
</li>
<li><ol>
<li>方法：<strong>从中间向两边比较来判断是否回文，例a_b_c_b_a，则这个字符串abcba长度5，判断的位置有9个，然后从中间向两边展开，首先判断是否出界，再看是不是相等，这样最后更新长度和字符串</strong></li>
</ol>
</li>
<li>5.　本文属于<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最系列</a>的应用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spiral Matrix]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/spiral-matrix/"/>
    <updated>2014-07-18T19:01:52+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/spiral-matrix</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/spiral-matrix/">Spiral Matrix</a></h4>

<h5>Problem</h5>

<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>

<p>For example,</p>

<p>Given the following matrix:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[1,2,3]
</span><span class='line'>[4,5,6]
</span><span class='line'>[7,8,9]</span></code></pre></td></tr></table></div></figure>


<p>You should return<code>[1,2,3,6,8,9,7,4,5]</code></p>

<!--more-->


<h5>Code</h5>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Solution {
</span><span class='line'>public:
</span><span class='line'>    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt; &gt; &matrix)
</span><span class='line'>    {
</span><span class='line'>        vector&lt;int&gt;result;
</span><span class='line'>        result.clear();
</span><span class='line'>        int row = matrix.size();
</span><span class='line'>        if(row==0)return result;
</span><span class='line'>        int col = matrix[0].size();
</span><span class='line'>        int rowleft = 0, rowright = col -1;
</span><span class='line'>        int coltop = 0, colbott = row -1;
</span><span class='line'>        int i=0,j=0;
</span><span class='line'>        int dir = 1;
</span><span class='line'>        while(rowleft&lt;=rowright&&coltop&lt;=colbott)
</span><span class='line'>        {
</span><span class='line'>            switch(dir)
</span><span class='line'>            {
</span><span class='line'>                case 1:   //toright
</span><span class='line'>                    while(rowleft&lt;=rowright&&j&gt;=rowleft&&j&lt;=rowright)
</span><span class='line'>                    {
</span><span class='line'>                        result.push_back(matrix[i][j]);
</span><span class='line'>                        j++;
</span><span class='line'>                    }
</span><span class='line'>                    j--;
</span><span class='line'>                    i++;
</span><span class='line'>                    coltop++;
</span><span class='line'>                    dir = 2;
</span><span class='line'>                    break;
</span><span class='line'>                case 2: //tobott
</span><span class='line'>                   while(coltop&lt;=colbott&&i&gt;=coltop&&i&lt;=colbott)
</span><span class='line'>                   {
</span><span class='line'>                       result.push_back(matrix[i][j]);
</span><span class='line'>                       i++;
</span><span class='line'>                   }
</span><span class='line'>                   i--;
</span><span class='line'>                   j--;
</span><span class='line'>                   rowright--;
</span><span class='line'>                   dir = 3;
</span><span class='line'>                   break;
</span><span class='line'>                case 3: //toleft
</span><span class='line'>                 while(rowleft&lt;=rowright&&j&gt;=rowleft&&j&lt;=rowright)
</span><span class='line'>                 {
</span><span class='line'>                     result.push_back(matrix[i][j]);
</span><span class='line'>                     j--;
</span><span class='line'>                 }
</span><span class='line'>                 j++;
</span><span class='line'>                 i--;
</span><span class='line'>                 colbott--;
</span><span class='line'>                 dir = 4;
</span><span class='line'>                 break;
</span><span class='line'>                case 4:  //totop
</span><span class='line'>                 while(coltop&lt;=colbott&&i&gt;=coltop&&i&lt;=colbott)
</span><span class='line'>                 {
</span><span class='line'>                      result.push_back(matrix[i][j]);
</span><span class='line'>                      i--;
</span><span class='line'>                 }
</span><span class='line'>                 i++;
</span><span class='line'>                 j++;
</span><span class='line'>                 rowleft++;
</span><span class='line'>                 dir = 1;
</span><span class='line'>                 break;
</span><span class='line'>                 default:
</span><span class='line'>                    break;
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>      
</span><span class='line'>        return result;
</span><span class='line'>    }
</span><span class='line'>};</span></code></pre></td></tr></table></div></figure>


<p>有很多种方法，这是自己的一种实</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[李天一列传]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/li-tian-%5B%3F%5D-lie-chuan/"/>
    <updated>2014-07-18T16:57:08+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/li-tian-[?]-lie-chuan</id>
    <content type="html"><![CDATA[<h4><strong>屎记　李天一列传</strong></h4>

<p><strong>文兄</strong></p>

<!--more-->


<hr />

<p>李天一，字冠丰，长安海淀人也。父两江，伶官也，以狎歌得宠，捧之歌王，颇得上赞许，封誉无数。天一好游侠，喜交接，眉清目秀，雄姿英发。尝与父同演，时人渐知其名。母梦鸟，荧屏之上尽吐相夫教子之法。根正苗红，其所谓也。未冠既海内闻名，当世人奇之。</p>

<p>天一孩提之时，便懂鼓琴，童龀之年，即会书法，幼学之际，渐通冰球。凡此种种，不一而足，可谓全才。其父甚喜，遂请名家教之。尝偕其交接权贵，以为后靠，现身荧屏，以养盛名。又系钟鸣鼎食之家，富家权贵之族，必国之大器也。天下第一，恰如其名，亦其父之所盼也。天一系老来子，捧之心肝，又类己，两江宠之尤甚。故宝马香车，无所不予，锦衣雕裘，毫不吝惜。少时米国游学，未冠既海归故里。</p>

<p>天一好宝马，喜美色，甚类其父。尝驱马游街，风驰电掣之状，迅雷不及万一也。行人如遇鬼神，唯恐避之不及。天一见状，快然自乐。先时，天一与其友各得一名驹，相与赛驰。天一为别驾所阻，稍逊其友。见所阻者形容甚猥，乃恶语加之。然此人不知其大名，竟起而理论。当时，众友于侧，天一颜面尽失，怒发冲冠，挥拳相向。天一身长八尺，力能扛鼎，无与争锋。狂殴几死乃止。或唤巡捕房。天一愈怒曰：“敢生事者死！竖子焉知吾父其谁？” 乃扬长而去。有司惮其父威，息事宁人。其父多以钱财了结此事。天一遂骄恣日长，乃恣意纵情，豪掷千金，游逞市井，结交朋党，不务正业。</p>

<p>及长，略懂云雨之事。尝闻天一侮其师，其师乃有夫之妇，畏两江夫妇淫威，不敢发。遂得诨名：海淀银枪小霸王。一晚，偕友数人章台游冶。酒酣耳热之际，灯火阑珊之处，见一女子，仪容艳丽，眉目清明。误以为陪酒，欲谋不轨。趁其醉，遂行苟且。天一素豪气，事毕亦念其党，可怜此女，数遭其辱。天一视若无事，恨未携相机，记此盛事。然此烈女，诉至大理寺，非钱财所能屈也。一时，世人哗然，海内震动，外邦亦引为笑谈。有司畏滔滔民意，汹汹舆情，不敢不察。两江素善钻研、勤于奔走，又门生故吏遍布朝野，多有名伶教授为之辩解，更添权贵为之开脱，指鹿为马、颠倒黑白更不在话下。或曰：此女系风尘，实索财未果反诬天一。又太学教授易延友曰：陪酒之女，人微命贱，侮之，其害甚小。梦鸟亦哭亦诉，其状生不如死，有司怜之。然不知梦鸟本两江之徒，素善演技。时平哥元年，始推新政，严惩腐败。国人久遭苛政，素淫官威。深恶权贵鱼肉。当时，群情激动，请愿之声不绝。纵两江四处走动，亦不免身败名裂，其子囹圄。</p>

<p>文兄曰：昔陈涉诚不知王侯将相，确有其种。富贵之家，官宦子弟，本无饥寒之忧，无从业之虑。固其立业之机，倍于庶民，其功成之道，数于常人。 然其不争，流恶乡里，何也？ 古今纨绔之所同也！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate Image]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/rotate-image/"/>
    <updated>2014-07-18T16:44:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/rotate-image</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/rotate-image/">Rotate Image</a></h4>

<h5>Problem:</h5>

<p>You are given an n x n 2D matrix representing an image.</p>

<p>Rotate the image by 90 degrees (clockwise).</p>

<p>Follow up:
Could you do this in-place?</p>

<!--more-->


<h5>Code:</h5>

<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)
    {
        int row = matrix.size();
        int col = matrix[0].size();
        // 
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;i;j++)
            swap(matrix[i][j],matrix[j][i]);
        //
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;col/2;j++)
            swap(matrix[i][j],matrix[i][col-1-j]);

    }
};
</code></pre>

<h5>说明</h5>

<ul>
<li><p>1.从windows下粘贴来的代码后面会有<sup>M</sup>的结尾，原因是换行符的约定问题，在vim中很容易删除，用:%s/^M//g即可，但此处的<sup>M</sup>需要用Ctrl+V再加上M得到</p></li>
<li><p>2.这题方法不是很多，先正对角线换，再左右换；或者逆对角线，再左右</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees Ii]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii/"/>
    <updated>2014-07-18T16:14:31+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/unique-binary-search-trees-ii/">Unique Binary Search Tree II</a></h4>

<!--more-->


<h5>Problem</h5>

<p>Given n, generate all structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n.</p>

<h5>Code</h5>

<pre><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode *&gt; generate(int beg, int end)
    {
        vector&lt;TreeNode* &gt; ret;
        if (beg &gt; end)
        {
            ret.push_back(NULL);
            return ret;
        }

        for(int i = beg; i &lt;= end; i++)
        {
            vector&lt;TreeNode* &gt; leftTree = generate(beg, i - 1);
            vector&lt;TreeNode* &gt; rightTree = generate(i + 1, end);
            for(int j = 0; j &lt; leftTree.size(); j++)
                for(int k = 0; k &lt; rightTree.size(); k++)
                {
                    TreeNode *node = new TreeNode(i + 1);
                    ret.push_back(node);
                    node-&gt;left = leftTree[j];
                    node-&gt;right = rightTree[k];              
                }           
        }

        return ret;
    }

    vector&lt;TreeNode *&gt; generateTrees(int n) {
        return generate(0, n - 1);
    }
};
</code></pre>

<h5>注意</h5>

<ul>
<li>1.此题第一想法就应试是递归或DFS</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insert Interval]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/insert-interval/"/>
    <updated>2014-07-18T15:40:02+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/insert-interval</id>
    <content type="html"><![CDATA[<h4>leetcode-Insert interval</h4>

<h5>题干</h5>

<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>

<p>You may assume that the intervals were initially sorted according to their start times.</p>

<p>Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>

<p>Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>

<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>

<!--more-->


<p>这题被虐了十几次，耗时半日．</p>

<p>其实逻辑简单，只是处理起来麻烦，如果有调试会更简单，只是平台上面只有结果．</p>

<h5>code</h5>

<pre><code>/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
bool  cmp(Interval interval1, Interval interval2)
{
        return interval1.start&lt;interval2.start;
}
class Solution {
public:

    vector&lt;Interval&gt; insert(vector&lt;Interval&gt; &amp;intervals, Interval newInterval) 
    {
         int size = intervals.size();
         intervals.push_back(newInterval);
         if(size==0)
            return intervals;  // pitfall1
        sort(intervals.begin(), intervals.end(), cmp);
        vector&lt;Interval&gt; result;
        int starts, ends;
        size++;
        int i,j;
        for(i=0;i&lt;size;i++)
        {
            starts = intervals[i].start;
            ends   = intervals[i].end;
            for(j=i+1;j&lt;size;j++)
            {
                if(ends&lt;intervals[j].start)
                  {
                    Interval tmp(starts, ends);
                    result.push_back(tmp);
                     break;
                  }
                 else if(ends&gt;=intervals[j].start&amp;&amp;ends&lt;=intervals[j].end)
                 {
                     ends = intervals[j].end;
                     i = j; //pitfall2
                 }
                 else
                    i = j; //pitfall3
            }
            if(size==j)
             {
                    Interval tmp(starts, ends);
                    result.push_back(tmp);
                    break;
             }
        }
        return result;
    }
};
</code></pre>

<p>三个pitfalls，首先按starts排序，然后遍历，其中要更新的不止是ends的值，还有是i也要更新，这样，就略过了．</p>

<h5>Bug</h5>

<ul>
<li><ol>
<li>关于sort排序，应该放在class之外，否则会报错</li>
</ol>
</li>
<li><ol>
<li>vector也有sort函数</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++中sort报错]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/c-plus-plus-zhong-sortbao-cuo/"/>
    <updated>2014-07-18T12:25:35+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/c-plus-plus-zhong-sortbao-cuo</id>
    <content type="html"><![CDATA[<h4>C++中报错</h4>

<p><strong> no matching function for call to &lsquo;sort&rsquo;</strong></p>

<!--more-->


<p>具体：</p>

<p>代码如下：</p>

<pre><code>class Solution {
public:
bool  cmp(Interval interval1, Interval interval2)
{
        return interval1.start&lt;interval2.start;
};
int f()
{
    ...
    sort(intervals.begin(),intervals.end(),cmp);
    ...
}
};
</code></pre>

<p>此处用法错误，不知是否察觉：</p>

<p><strong> no matching function for call to &lsquo;sort&rsquo;</strong></p>

<p>解决之法：</p>

<p>将cmp的定义置于class之外</p>

<p>可以将sort定义在结构体之内，这样就直接intervals.sort(&hellip;)；如果定义在之外，要放在类的外面</p>
]]></content>
  </entry>
  
</feed>
