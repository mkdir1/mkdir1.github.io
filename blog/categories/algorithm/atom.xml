<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-08-13T10:24:50+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Itoa]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/12/itoa/"/>
    <updated>2014-08-12T16:05:35+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/12/itoa</id>
    <content type="html"><![CDATA[<h4>ITOA</h4>

<p>一个很实现十进制整数转变成任意2-16进制字符串的代码，写得短小精练，原作者确实厉害，叹服</p>

<!--more-->


<h5>code</h5>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>char *my_itoa(int value, int radix) {</p>

<pre><code>static char buf[32] = {0};
int i = 30;
for(;value&amp;&amp;(i&gt;=0);--i,value/=radix) {
    buf[i] = "0123456789abcdef"[value%radix];
}
return &amp;buf[i+1];
</code></pre>

<p>}
int main()
{</p>

<pre><code>int val, radix;
while(~scanf("%d %d",&amp;val,&amp;radix))
    printf("%s\n",my_itoa(val,radix));
return 0;
</code></pre>

<p>}
```</p>

<p>仔细体会一下，　enjoy coding&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode-copy List With Random Pointer]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/28/leetcode-copy-list-with-random-pointer/"/>
    <updated>2014-07-28T00:53:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/28/leetcode-copy-list-with-random-pointer</id>
    <content type="html"><![CDATA[<h4>Copy List with random pointer</h4>

<p>这题早就看过，解法也知道，但是，想法与代码差距很大，半天都没发现错误．还得多多练习</p>

<!--more-->


<h5>Problem</h5>

<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>

<p>Return a deep copy of the list.</p>

<h5>code:</h5>

<p>``` c++
/<em><em>
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode </em>next, </em>random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:</p>

<pre><code>RandomListNode *copyRandomList(RandomListNode *head) 
{
    RandomListNode *Head = head;
    if(NULL==head)
        return NULL;
    RandomListNode *p,*q;
    p = head;
    while(NULL!=p)
    {
        q = new RandomListNode(p-&gt;label);
        q-&gt;next = p-&gt;next;
        p-&gt;next = q;
        p = q-&gt;next;
    }
    p = head;
    while(NULL!=p)
    {
        if(p-&gt;random!=NULL) //　这里可能为空
            p-&gt;next-&gt;random = p-&gt;random-&gt;next;
        else
            p-&gt;next-&gt;random = NULL;
         p = p-&gt;next-&gt;next;
    }
    Head = head-&gt;next;
    p = head;
    q = Head;
    if(NULL==q-&gt;next)
    {
        p-&gt;next = NULL;
        return Head;
    }
    while(NULL!=q-&gt;next)
    {
        p-&gt;next =  q-&gt;next;
        p = p-&gt;next;
        q-&gt;next = p-&gt;next;
        q = q-&gt;next;
    }
   p-&gt;next = NULL;// 这里要断开
    return Head;
}
</code></pre>

<p>};
```</p>

<p>两处注释的地方，瞪大眼睛都没看出来．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[leetcode-4Sum]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/27/leetcode-4sum/"/>
    <updated>2014-07-27T16:14:07+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/27/leetcode-4sum</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/4sum/">Leetcode-4Sum</a></h4>

<hr />

<p>此题不难，但编码起来，许多细节需要注意．wrong了好多次，发现有两处画蛇添足，良久才恍然大悟．<br/>
有时候，思维逻辑正确，也不能保证编码不出小差错．</p>

<!--more-->


<h5>Problem:</h5>

<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>

<p>Note:
Elements in a quadruplet <code>(a,b,c,d)</code> must be in non-descending order. <code>(ie, a ≤ b ≤ c ≤ d)</code></p>

<p>The solution set must not contain duplicate quadruplets.</p>

<pre><code>For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
</code></pre>

<p>```</p>

<pre><code>A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
</code></pre>

<p>```</p>

<h5>Code:</h5>

<p>``` c++
class Solution {
public:</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) 
{
    int len = num.size();
    sort(num.begin(),num.end());
    int i,j,k,l;
    vector&lt;vector&lt;int&gt;&gt;result;
    vector&lt;int&gt; vec;
    int sum;
    for(i=0;i&lt;len-3;i++)
    {
        if(i&gt;0&amp;&amp;num[i]==num[i-1])
        {
          //  i++;
            continue;
        }
        for(j=i+1;j&lt;len-2;j++)
        {
            if(j&gt;i+1&amp;&amp;num[j]==num[j-1])
            {
               // j++;
                continue;
            }
            l = len-1;
            k = j+1;
            while(l&gt;k)
            {
                if(l&lt;len-1&amp;&amp;num[l]==num[l+1])
                {
                    l--;
                    continue;
                }
                if(k&gt;j+1&amp;&amp;num[k]==num[k-1])
                {
                    k++;
                    continue;
                }
                sum = num[i]+num[j]+num[k]+num[l];
                if(sum&gt;target)
                {
                    l--;
                    continue;
                }
                if(sum&lt;target)
                {
                    k++;
                    continue;
                }
                vec.push_back(num[i]);  
                vec.push_back(num[j]);  
                vec.push_back(num[k]);  
                vec.push_back(num[l]);
                result.push_back(vec);
                vec.clear();
                k++;
            }
        }
    }
    return result;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ACM 重定向]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/25/acm-zhong-ding-xiang/"/>
    <updated>2014-07-25T09:07:06+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/25/acm-zhong-ding-xiang</id>
    <content type="html"><![CDATA[<h4>ACM输入输出重定向</h4>

<p>问题描述：<br/>
在做ACM题时，对于输入输出，总需要键盘来操作，这样显然不方向，对于多数据的测试，显然不合理，现有一个实用的重定向函数，可很好解决.</p>

<!--more-->


<h5>解决</h5>

<p>首先，gcc中有一个－D选项，这样表示在文件中添加宏定义</p>

<pre><code>gcc -o example example.c -D TAG
</code></pre>

<p>在正文中添加</p>

<pre><code>#ifndef TAG
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt+", stdout);
#endif
</code></pre>

<p>这样，就直接可以重定向到两个文件中．</p>

<p>包含在<code>#include&lt;stdio.h&gt;</code>中</p>

<hr />

<h5>另外</h5>

<p>在windows下找到一个解决方案，有bat文件中<code>example.exe&lt;input.txt&gt;output.txt</code> 不过，一般有IDE中就解决了，不必这么麻烦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sudoku-solver]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/sudoku-solver/"/>
    <updated>2014-07-22T20:27:47+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/sudoku-solver</id>
    <content type="html"><![CDATA[<h4>Sudoku Solver</h4>

<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>Empty cells are indicated by the character &lsquo;.&rsquo;.</p>

<p>You may assume that there will be only one unique solution.</p>

<!--more-->


<p>递归的方法，确实不错～　</p>

<h5>Code</h5>

<pre><code>bool isValid(vector&lt;vector&lt;char&gt; &gt; &amp;board, int a, int b) {
        int i,j;
        for(i = 0; i &lt; 9; i++)
            if(i != a &amp;&amp; board[i][b] == board[a][b])
                return false;

        for(j = 0; j &lt; 9; j++)
            if(j != b &amp;&amp; board[a][j] == board[a][b])
                return false;

        int x = a/3*3;
        int y = b/3*3;
        for(i = 0; i &lt; 3; i++)
            for(j = 0; j&lt; 3; j++)
                if(x+i != a &amp;&amp; y+j != b &amp;&amp; board[x+i][y+j] == board[a][b])
                    return false;
        return true;
    }
    bool solveSudokudfs(vector&lt;vector&lt;char&gt; &gt; &amp;board)
    {
        for(int i = 0; i &lt; 9; i++)
            for(int j = 0; j &lt; 9; j++)
            {
                if(board[i][j] == '.')
                {
                    for(int k = 1; k &lt;= 9; k++)
                    {
                        board[i][j] = '0' + k;
                        if(isValid(board,i,j) &amp;&amp; solveSudokudfs(board))
                            return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        return true;
    }
    void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) {
        // Note: The Solution object is instantiated only once.
        solveSudokudfs(board);
    }
</code></pre>
]]></content>
  </entry>
  
</feed>
