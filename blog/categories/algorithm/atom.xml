<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-08-25T01:16:49+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最小绝对值]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/22/zui-xiao-jue-dui-zhi/"/>
    <updated>2014-08-22T21:31:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/22/zui-xiao-jue-dui-zhi</id>
    <content type="html"><![CDATA[<h4>求一个递增序列中绝对值最小的数</h4>

<p>比如(-3, -1, 2,4,6),返回-1</p>

<p>当然，时间小于O(n)</p>

<!--more-->


<p>```</p>

<h1>include&lt;stdio.h></h1>

<h1>define ABS(x,y) ((-x)>=(y)?(y):(x))</h1>

<p>int GetAbsMin(int *a, int n)
{</p>

<pre><code>if(a[0]&gt;=0)return a[0];
if(a[n-1]&lt;=0)return a[n-1];
int begin = 0;
int end   = n-1;

int left = a[0];
int right = a[n-1];
int mid;
while(begin&lt;=end)
{
    mid = (begin+end)/2;
    if(a[mid]==0)return 0;
    if(a[mid]&gt;0)
    {
        if(a[mid-1]&lt;0)
        {
            left = a[mid-1];
            right = a[mid];
            break;
        }
        else
        {
            end = mid-1;
        }
    }
    else
    {
        if(a[mid+1]&gt;0)
        {
            left=a[mid];
            right=a[mid+1];
            break;
        }
        else
            begin = mid + 1;
    }

}
return ABS(left,right);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>int n,i;
int a[100];
int result;
while(~scanf("%d",&amp;n))
{
    for(i=0;i&lt;n;i++)
        scanf("%d",&amp;a[i]);
   result =  GetAbsMin(a,n); 
   printf("%d\n",result);
}
return 0;
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进制转化]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/18/jin-zhi-zhuan-hua/"/>
    <updated>2014-08-18T17:35:10+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/18/jin-zhi-zhuan-hua</id>
    <content type="html"><![CDATA[<h4>进制转化</h4>

<p>改进了一下进制转化的代码，每次都有进步</p>

<!--more-->


<h5>Code</h5>

<p>```</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;string.h></h1>

<p>char result[1000];
static int Name[36]={&lsquo;0&rsquo;,&lsquo;1&rsquo;,&lsquo;2&rsquo;,&lsquo;3&rsquo;,&lsquo;4&rsquo;,&lsquo;5&rsquo;,&lsquo;6&rsquo;,&lsquo;7&rsquo;,&lsquo;8&rsquo;,&lsquo;9&rsquo;,&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;,&rsquo;D',&lsquo;E&rsquo;,&lsquo;F&rsquo;,&lsquo;G&rsquo;,&lsquo;H&rsquo;,&lsquo;I&rsquo;,&lsquo;J&rsquo;,&lsquo;K&rsquo;,&lsquo;L&rsquo;,&rsquo;M',&lsquo;N&rsquo;,&lsquo;O&rsquo;,&lsquo;P&rsquo;,&lsquo;Q&rsquo;,&lsquo;R&rsquo;,&rsquo;S',&rsquo;T',&lsquo;U&rsquo;,&lsquo;V&rsquo;,&lsquo;W&rsquo;,&lsquo;X&rsquo;,&lsquo;Y&rsquo;,&lsquo;Z&rsquo;};</p>

<p>void reverse(char *p)
{</p>

<pre><code>int len = strlen(p);
int i = 0;
int j = len-1;
char ch;
while(i&lt;j)
{
    ch = p[i];
    p[i] = p[j];
    p[j] = ch;
    i++;
    j--;
}
return;
</code></pre>

<p>}
void conver(int n, int m)<br/>
{</p>

<pre><code>int signal = 0;
int i = 0;
if(n&lt;0)
{
    n = -n;
    signal = -1;
    i= 1;
}
while(n/m!=0)
{
    result[i++] = Name[n%m];
    n = n/m;
}
result[i] = Name[n];
result[i+1] = 0;
if(signal==-1)
{
    result[0] = '-';
    reverse(result+1);
}
else
    reverse(result);
printf("%s\n",result);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>int n,m;
while(~scanf("%d %d",&amp;n,&amp;m))
    conver(n,m);
return 0;
</code></pre>

<p>}
```
将十进制n转化成m进制的字符串输出
这里还可以进一步的是，将十进制的字符串
void conver(char *n, int m)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Itoa]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/12/itoa/"/>
    <updated>2014-08-12T16:05:35+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/12/itoa</id>
    <content type="html"><![CDATA[<h4>ITOA</h4>

<p>一个很实现十进制整数转变成任意2-16进制字符串的代码，写得短小精练，原作者确实厉害，叹服</p>

<!--more-->


<h5>code</h5>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>char *my_itoa(int value, int radix) {</p>

<pre><code>static char buf[32] = {0};
int i = 30;
for(;value&amp;&amp;(i&gt;=0);--i,value/=radix) {
    buf[i] = "0123456789abcdef"[value%radix];
}
return &amp;buf[i+1];
</code></pre>

<p>}
int main()
{</p>

<pre><code>int val, radix;
while(~scanf("%d %d",&amp;val,&amp;radix))
    printf("%s\n",my_itoa(val,radix));
return 0;
</code></pre>

<p>}
```</p>

<p>仔细体会一下，　enjoy coding&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode-copy List With Random Pointer]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/28/leetcode-copy-list-with-random-pointer/"/>
    <updated>2014-07-28T00:53:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/28/leetcode-copy-list-with-random-pointer</id>
    <content type="html"><![CDATA[<h4>Copy List with random pointer</h4>

<p>这题早就看过，解法也知道，但是，想法与代码差距很大，半天都没发现错误．还得多多练习</p>

<!--more-->


<h5>Problem</h5>

<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>

<p>Return a deep copy of the list.</p>

<h5>code:</h5>

<p>``` c++
/<em><em>
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode </em>next, </em>random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:</p>

<pre><code>RandomListNode *copyRandomList(RandomListNode *head) 
{
    RandomListNode *Head = head;
    if(NULL==head)
        return NULL;
    RandomListNode *p,*q;
    p = head;
    while(NULL!=p)
    {
        q = new RandomListNode(p-&gt;label);
        q-&gt;next = p-&gt;next;
        p-&gt;next = q;
        p = q-&gt;next;
    }
    p = head;
    while(NULL!=p)
    {
        if(p-&gt;random!=NULL) //　这里可能为空
            p-&gt;next-&gt;random = p-&gt;random-&gt;next;
        else
            p-&gt;next-&gt;random = NULL;
         p = p-&gt;next-&gt;next;
    }
    Head = head-&gt;next;
    p = head;
    q = Head;
    if(NULL==q-&gt;next)
    {
        p-&gt;next = NULL;
        return Head;
    }
    while(NULL!=q-&gt;next)
    {
        p-&gt;next =  q-&gt;next;
        p = p-&gt;next;
        q-&gt;next = p-&gt;next;
        q = q-&gt;next;
    }
   p-&gt;next = NULL;// 这里要断开
    return Head;
}
</code></pre>

<p>};
```</p>

<p>两处注释的地方，瞪大眼睛都没看出来．</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[leetcode-4Sum]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/27/leetcode-4sum/"/>
    <updated>2014-07-27T16:14:07+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/27/leetcode-4sum</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/4sum/">Leetcode-4Sum</a></h4>

<hr />

<p>此题不难，但编码起来，许多细节需要注意．wrong了好多次，发现有两处画蛇添足，良久才恍然大悟．<br/>
有时候，思维逻辑正确，也不能保证编码不出小差错．</p>

<!--more-->


<h5>Problem:</h5>

<p>Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.</p>

<p>Note:
Elements in a quadruplet <code>(a,b,c,d)</code> must be in non-descending order. <code>(ie, a ≤ b ≤ c ≤ d)</code></p>

<p>The solution set must not contain duplicate quadruplets.</p>

<pre><code>For example, given array S = {1 0 -1 0 -2 2}, and target = 0.
</code></pre>

<p>```</p>

<pre><code>A solution set is:
(-1,  0, 0, 1)
(-2, -1, 1, 2)
(-2,  0, 0, 2)
</code></pre>

<p>```</p>

<h5>Code:</h5>

<p>``` c++
class Solution {
public:</p>

<pre><code>vector&lt;vector&lt;int&gt; &gt; fourSum(vector&lt;int&gt; &amp;num, int target) 
{
    int len = num.size();
    sort(num.begin(),num.end());
    int i,j,k,l;
    vector&lt;vector&lt;int&gt;&gt;result;
    vector&lt;int&gt; vec;
    int sum;
    for(i=0;i&lt;len-3;i++)
    {
        if(i&gt;0&amp;&amp;num[i]==num[i-1])
        {
          //  i++;
            continue;
        }
        for(j=i+1;j&lt;len-2;j++)
        {
            if(j&gt;i+1&amp;&amp;num[j]==num[j-1])
            {
               // j++;
                continue;
            }
            l = len-1;
            k = j+1;
            while(l&gt;k)
            {
                if(l&lt;len-1&amp;&amp;num[l]==num[l+1])
                {
                    l--;
                    continue;
                }
                if(k&gt;j+1&amp;&amp;num[k]==num[k-1])
                {
                    k++;
                    continue;
                }
                sum = num[i]+num[j]+num[k]+num[l];
                if(sum&gt;target)
                {
                    l--;
                    continue;
                }
                if(sum&lt;target)
                {
                    k++;
                    continue;
                }
                vec.push_back(num[i]);  
                vec.push_back(num[j]);  
                vec.push_back(num[k]);  
                vec.push_back(num[l]);
                result.push_back(vec);
                vec.clear();
                k++;
            }
        }
    }
    return result;
}
</code></pre>

<p>};
```</p>
]]></content>
  </entry>
  
</feed>
