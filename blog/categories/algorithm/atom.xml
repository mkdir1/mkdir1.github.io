<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-18T21:31:55+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring/"/>
    <updated>2014-07-18T21:22:53+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h5><a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a></h5>

<h5>Probles</h5>

<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>

<p>看本站内的总结：<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最长回文字符串</a></p>

<!--more-->


<h5>Code</h5>

<p>```
class Solution {
public:</p>

<pre><code>string longestPalindrome(string s)
{
    int len = s.length();
    string str="";
    if(len==0)return str;
    int maxlen = 0;
    int leng;
    int left,right;
    for(int i=0;i&lt;2*len-1;i++)
    {
        if(i%2==0)
        {
            leng = 1;
            left = i/2 - 1;
            right = i/2 + 1;
            while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s.at(left)==s.at(right))
            {
                leng += 2;
                left--;
                right++;
            }
             if(leng&gt;maxlen)
          {
                maxlen = leng;
                str = s.substr(i/2-maxlen/2, maxlen);
          }
        }
        else
        {
            leng = 0;
            left = i/2;
            right = i/2+1;
             while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s[left]==s[right])
            {
                leng += 2;
                left--;
                right++;
            }


         if(leng&gt;maxlen)
          {
                maxlen = leng;
                str = s.substr(i/2-maxlen/2+1, maxlen);
          }
        }
    }
    return str;
}
</code></pre>

<p>};
```</p>

<h5>注意</h5>

<ul>
<li><ol>
<li>把奇偶统一起来，这样i的大小是2len-1的大小</li>
</ol>
</li>
<li><ol>
<li>还有一个注意点是，substr()这个两个参数是指起始和长度，起始从0开始就算第一个</li>
</ol>
</li>
<li><ol>
<li>后面两个if判断不能统一起来，因为substr中的参数不一样</li>
</ol>
</li>
<li><ol>
<li>方法：<strong>从中间向两边比较来判断是否回文，例a_b_c_b_a，则这个字符串abcba长度5，判断的位置有9个，然后从中间向两边展开，首先判断是否出界，再看是不是相等，这样最后更新长度和字符串</strong></li>
</ol>
</li>
<li>5.　本文属于<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最系列</a>的应用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spiral Matrix]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/spiral-matrix/"/>
    <updated>2014-07-18T19:01:52+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/spiral-matrix</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/spiral-matrix/">Spiral Matrix</a></h4>

<h5>Problem</h5>

<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>

<p>For example,</p>

<p>Given the following matrix:
```</p>

<pre><code>[1,2,3]
[4,5,6]
[7,8,9]
</code></pre>

<p><code>``
You should return</code>[1,2,3,6,8,9,7,4,5]`</p>

<!--more-->


<h5>Code</h5>

<p>```
class Solution {
public:</p>

<pre><code>vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)
{
    vector&lt;int&gt;result;
    result.clear();
    int row = matrix.size();
    if(row==0)return result;
    int col = matrix[0].size();
    int rowleft = 0, rowright = col -1;
    int coltop = 0, colbott = row -1;
    int i=0,j=0;
    int dir = 1;
    while(rowleft&lt;=rowright&amp;&amp;coltop&lt;=colbott)
    {
        switch(dir)
        {
            case 1:   //toright
                while(rowleft&lt;=rowright&amp;&amp;j&gt;=rowleft&amp;&amp;j&lt;=rowright)
                {
                    result.push_back(matrix[i][j]);
                    j++;
                }
                j--;
                i++;
                coltop++;
                dir = 2;
                break;
            case 2: //tobott
               while(coltop&lt;=colbott&amp;&amp;i&gt;=coltop&amp;&amp;i&lt;=colbott)
               {
                   result.push_back(matrix[i][j]);
                   i++;
               }
               i--;
               j--;
               rowright--;
               dir = 3;
               break;
            case 3: //toleft
             while(rowleft&lt;=rowright&amp;&amp;j&gt;=rowleft&amp;&amp;j&lt;=rowright)
             {
                 result.push_back(matrix[i][j]);
                 j--;
             }
             j++;
             i--;
             colbott--;
             dir = 4;
             break;
            case 4:  //totop
             while(coltop&lt;=colbott&amp;&amp;i&gt;=coltop&amp;&amp;i&lt;=colbott)
             {
                  result.push_back(matrix[i][j]);
                  i--;
             }
             i++;
             j++;
             rowleft++;
             dir = 1;
             break;
             default:
                break;
        }
    }

    return result;
}
</code></pre>

<p>};
```
有很多种方法，这是自己的一种实</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate Image]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/rotate-image/"/>
    <updated>2014-07-18T16:44:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/rotate-image</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/rotate-image/">Rotate Image</a></h4>

<h5>Problem:</h5>

<p>You are given an n x n 2D matrix representing an image.</p>

<p>Rotate the image by 90 degrees (clockwise).</p>

<p>Follow up:
Could you do this in-place?</p>

<!--more-->


<h5>Code:</h5>

<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)
    {
        int row = matrix.size();
        int col = matrix[0].size();
        // 
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;i;j++)
            swap(matrix[i][j],matrix[j][i]);
        //
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;col/2;j++)
            swap(matrix[i][j],matrix[i][col-1-j]);

    }
};
</code></pre>

<h5>说明</h5>

<ul>
<li><p>1.从windows下粘贴来的代码后面会有<sup>M</sup>的结尾，原因是换行符的约定问题，在vim中很容易删除，用:%s/^M//g即可，但此处的<sup>M</sup>需要用Ctrl+V再加上M得到</p></li>
<li><p>2.这题方法不是很多，先正对角线换，再左右换；或者逆对角线，再左右</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees Ii]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii/"/>
    <updated>2014-07-18T16:14:31+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/unique-binary-search-trees-ii/">Unique Binary Search Tree II</a></h4>

<!--more-->


<h5>Problem</h5>

<p>Given n, generate all structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n.</p>

<h5>Code</h5>

<pre><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode *&gt; generate(int beg, int end)
    {
        vector&lt;TreeNode* &gt; ret;
        if (beg &gt; end)
        {
            ret.push_back(NULL);
            return ret;
        }

        for(int i = beg; i &lt;= end; i++)
        {
            vector&lt;TreeNode* &gt; leftTree = generate(beg, i - 1);
            vector&lt;TreeNode* &gt; rightTree = generate(i + 1, end);
            for(int j = 0; j &lt; leftTree.size(); j++)
                for(int k = 0; k &lt; rightTree.size(); k++)
                {
                    TreeNode *node = new TreeNode(i + 1);
                    ret.push_back(node);
                    node-&gt;left = leftTree[j];
                    node-&gt;right = rightTree[k];              
                }           
        }

        return ret;
    }

    vector&lt;TreeNode *&gt; generateTrees(int n) {
        return generate(0, n - 1);
    }
};
</code></pre>

<h5>注意</h5>

<ul>
<li>1.此题第一想法就应试是递归或DFS</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Insert Interval]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/insert-interval/"/>
    <updated>2014-07-18T15:40:02+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/insert-interval</id>
    <content type="html"><![CDATA[<h4>leetcode-Insert interval</h4>

<h5>题干</h5>

<p>Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).</p>

<p>You may assume that the intervals were initially sorted according to their start times.</p>

<p>Example 1:
Given intervals [1,3],[6,9], insert and merge [2,5] in as [1,5],[6,9].</p>

<p>Example 2:
Given [1,2],[3,5],[6,7],[8,10],[12,16], insert and merge [4,9] in as [1,2],[3,10],[12,16].</p>

<p>This is because the new interval [4,9] overlaps with [3,5],[6,7],[8,10].</p>

<!--more-->


<p>这题被虐了十几次，耗时半日．</p>

<p>其实逻辑简单，只是处理起来麻烦，如果有调试会更简单，只是平台上面只有结果．</p>

<h5>code</h5>

<pre><code>/**
 * Definition for an interval.
 * struct Interval {
 *     int start;
 *     int end;
 *     Interval() : start(0), end(0) {}
 *     Interval(int s, int e) : start(s), end(e) {}
 * };
 */
bool  cmp(Interval interval1, Interval interval2)
{
        return interval1.start&lt;interval2.start;
}
class Solution {
public:

    vector&lt;Interval&gt; insert(vector&lt;Interval&gt; &amp;intervals, Interval newInterval) 
    {
         int size = intervals.size();
         intervals.push_back(newInterval);
         if(size==0)
            return intervals;  // pitfall1
        sort(intervals.begin(), intervals.end(), cmp);
        vector&lt;Interval&gt; result;
        int starts, ends;
        size++;
        int i,j;
        for(i=0;i&lt;size;i++)
        {
            starts = intervals[i].start;
            ends   = intervals[i].end;
            for(j=i+1;j&lt;size;j++)
            {
                if(ends&lt;intervals[j].start)
                  {
                    Interval tmp(starts, ends);
                    result.push_back(tmp);
                     break;
                  }
                 else if(ends&gt;=intervals[j].start&amp;&amp;ends&lt;=intervals[j].end)
                 {
                     ends = intervals[j].end;
                     i = j; //pitfall2
                 }
                 else
                    i = j; //pitfall3
            }
            if(size==j)
             {
                    Interval tmp(starts, ends);
                    result.push_back(tmp);
                    break;
             }
        }
        return result;
    }
};
</code></pre>

<p>三个pitfalls，首先按starts排序，然后遍历，其中要更新的不止是ends的值，还有是i也要更新，这样，就略过了．</p>

<h5>Bug</h5>

<ul>
<li><ol>
<li>关于sort排序，应该放在class之外，否则会报错</li>
</ol>
</li>
<li><ol>
<li>vector也有sort函数</li>
</ol>
</li>
</ul>

]]></content>
  </entry>
  
</feed>
