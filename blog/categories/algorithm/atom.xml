<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-22T17:09:10+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Leetcode-combination Sum]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/leetcode-combination-sum/"/>
    <updated>2014-07-22T17:05:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/leetcode-combination-sum</id>
    <content type="html"><![CDATA[<h4>Combination Sum</h4>

<p>Given a set of candidate numbers &copy; and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>

<p>The same repeated number may be chosen from C unlimited number of times.</p>

<p>Note:</p>

<p>All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</p>

<p>The solution set must not contain duplicate combinations.
For example, given candidate set 2,3,6,7 and target 7,
A solution set is:
```
[2,3,6,7] 7
[7]
[2, 2, 3]</p>

<p>```</p>

<!--more-->


<p>这题真是基础，之前一直对此类不知所措，现在略通一二，甚喜</p>

<p>Code:</p>

<pre><code>class Solution {
public:
    void Getcom(vector&lt;int&gt;&amp;can, int target, vector&lt;vector&lt;int&gt;&gt;&amp;result, int level, int &amp;sumcurrent, int nsize, vector&lt;int&gt;&amp;tmp)
    {
        if(sumcurrent&gt;target)return;
        if(target==sumcurrent)
        {
            result.push_back(tmp);
            return;
        }
        for(int i=level;i&lt;nsize;i++)
        {

                sumcurrent += can[i];
                tmp.push_back(can[i]);
                Getcom(can,target,result,i,sumcurrent,nsize,tmp);
                tmp.pop_back();
                sumcurrent -=can[i];
        }

    }
    vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) 
    {
       vector&lt;vector&lt;int&gt;&gt; result;
       vector&lt;int&gt;tmp;
       int size = candidates.size();
       sort(candidates.begin(),candidates.end());
       int sumc = 0;
       Getcom(candidates,target,result,0,sumc,size,tmp);
       return result;
    }
};
</code></pre>

<p>DFS方便记录结果，DP方便记数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring/"/>
    <updated>2014-07-18T21:22:53+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h5><a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a></h5>

<h5>Probles</h5>

<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>

<p>看本站内的总结：<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最长回文字符串</a></p>

<!--more-->


<h5>Code</h5>

<p>```
class Solution {
public:</p>

<pre><code>string longestPalindrome(string s)
{
    int len = s.length();
    string str="";
    if(len==0)return str;
    int maxlen = 0;
    int leng;
    int left,right;
    for(int i=0;i&lt;2*len-1;i++)
    {
        if(i%2==0)
        {
            leng = 1;
            left = i/2 - 1;
            right = i/2 + 1;
            while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s.at(left)==s.at(right))
            {
                leng += 2;
                left--;
                right++;
            }
             if(leng&gt;maxlen)
          {
                maxlen = leng;
                str = s.substr(i/2-maxlen/2, maxlen);
          }
        }
        else
        {
            leng = 0;
            left = i/2;
            right = i/2+1;
             while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s[left]==s[right])
            {
                leng += 2;
                left--;
                right++;
            }


         if(leng&gt;maxlen)
          {
                maxlen = leng;
                str = s.substr(i/2-maxlen/2+1, maxlen);
          }
        }
    }
    return str;
}
</code></pre>

<p>};
```</p>

<h5>注意</h5>

<ul>
<li><ol>
<li>把奇偶统一起来，这样i的大小是2len-1的大小</li>
</ol>
</li>
<li><ol>
<li>还有一个注意点是，substr()这个两个参数是指起始和长度，起始从0开始就算第一个</li>
</ol>
</li>
<li><ol>
<li>后面两个if判断不能统一起来，因为substr中的参数不一样</li>
</ol>
</li>
<li><ol>
<li>方法：<strong>从中间向两边比较来判断是否回文，例a_b_c_b_a，则这个字符串abcba长度5，判断的位置有9个，然后从中间向两边展开，首先判断是否出界，再看是不是相等，这样最后更新长度和字符串</strong></li>
</ol>
</li>
<li>5.　本文属于<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最系列</a>的应用</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spiral Matrix]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/spiral-matrix/"/>
    <updated>2014-07-18T19:01:52+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/spiral-matrix</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/spiral-matrix/">Spiral Matrix</a></h4>

<h5>Problem</h5>

<p>Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.</p>

<p>For example,</p>

<p>Given the following matrix:
```</p>

<pre><code>[1,2,3]
[4,5,6]
[7,8,9]
</code></pre>

<p><code>``
You should return</code>[1,2,3,6,8,9,7,4,5]`</p>

<!--more-->


<h5>Code</h5>

<p>```
class Solution {
public:</p>

<pre><code>vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)
{
    vector&lt;int&gt;result;
    result.clear();
    int row = matrix.size();
    if(row==0)return result;
    int col = matrix[0].size();
    int rowleft = 0, rowright = col -1;
    int coltop = 0, colbott = row -1;
    int i=0,j=0;
    int dir = 1;
    while(rowleft&lt;=rowright&amp;&amp;coltop&lt;=colbott)
    {
        switch(dir)
        {
            case 1:   //toright
                while(rowleft&lt;=rowright&amp;&amp;j&gt;=rowleft&amp;&amp;j&lt;=rowright)
                {
                    result.push_back(matrix[i][j]);
                    j++;
                }
                j--;
                i++;
                coltop++;
                dir = 2;
                break;
            case 2: //tobott
               while(coltop&lt;=colbott&amp;&amp;i&gt;=coltop&amp;&amp;i&lt;=colbott)
               {
                   result.push_back(matrix[i][j]);
                   i++;
               }
               i--;
               j--;
               rowright--;
               dir = 3;
               break;
            case 3: //toleft
             while(rowleft&lt;=rowright&amp;&amp;j&gt;=rowleft&amp;&amp;j&lt;=rowright)
             {
                 result.push_back(matrix[i][j]);
                 j--;
             }
             j++;
             i--;
             colbott--;
             dir = 4;
             break;
            case 4:  //totop
             while(coltop&lt;=colbott&amp;&amp;i&gt;=coltop&amp;&amp;i&lt;=colbott)
             {
                  result.push_back(matrix[i][j]);
                  i--;
             }
             i++;
             j++;
             rowleft++;
             dir = 1;
             break;
             default:
                break;
        }
    }

    return result;
}
</code></pre>

<p>};
```
有很多种方法，这是自己的一种实</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rotate Image]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/rotate-image/"/>
    <updated>2014-07-18T16:44:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/rotate-image</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/rotate-image/">Rotate Image</a></h4>

<h5>Problem:</h5>

<p>You are given an n x n 2D matrix representing an image.</p>

<p>Rotate the image by 90 degrees (clockwise).</p>

<p>Follow up:
Could you do this in-place?</p>

<!--more-->


<h5>Code:</h5>

<pre><code>class Solution {
public:
    void rotate(vector&lt;vector&lt;int&gt; &gt; &amp;matrix)
    {
        int row = matrix.size();
        int col = matrix[0].size();
        // 
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;i;j++)
            swap(matrix[i][j],matrix[j][i]);
        //
        for(int i=0;i&lt;row;i++)
        for(int j=0;j&lt;col/2;j++)
            swap(matrix[i][j],matrix[i][col-1-j]);

    }
};
</code></pre>

<h5>说明</h5>

<ul>
<li><p>1.从windows下粘贴来的代码后面会有<sup>M</sup>的结尾，原因是换行符的约定问题，在vim中很容易删除，用:%s/^M//g即可，但此处的<sup>M</sup>需要用Ctrl+V再加上M得到</p></li>
<li><p>2.这题方法不是很多，先正对角线换，再左右换；或者逆对角线，再左右</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Unique Binary Search Trees Ii]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii/"/>
    <updated>2014-07-18T16:14:31+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/unique-binary-search-trees-ii</id>
    <content type="html"><![CDATA[<h4><a href="https://oj.leetcode.com/problems/unique-binary-search-trees-ii/">Unique Binary Search Tree II</a></h4>

<!--more-->


<h5>Problem</h5>

<p>Given n, generate all structurally unique BST&rsquo;s (binary search trees) that store values 1&hellip;n.</p>

<h5>Code</h5>

<pre><code>/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    vector&lt;TreeNode *&gt; generate(int beg, int end)
    {
        vector&lt;TreeNode* &gt; ret;
        if (beg &gt; end)
        {
            ret.push_back(NULL);
            return ret;
        }

        for(int i = beg; i &lt;= end; i++)
        {
            vector&lt;TreeNode* &gt; leftTree = generate(beg, i - 1);
            vector&lt;TreeNode* &gt; rightTree = generate(i + 1, end);
            for(int j = 0; j &lt; leftTree.size(); j++)
                for(int k = 0; k &lt; rightTree.size(); k++)
                {
                    TreeNode *node = new TreeNode(i + 1);
                    ret.push_back(node);
                    node-&gt;left = leftTree[j];
                    node-&gt;right = rightTree[k];              
                }           
        }

        return ret;
    }

    vector&lt;TreeNode *&gt; generateTrees(int n) {
        return generate(0, n - 1);
    }
};
</code></pre>

<h5>注意</h5>

<ul>
<li>1.此题第一想法就应试是递归或DFS</li>
</ul>

]]></content>
  </entry>
  
</feed>
