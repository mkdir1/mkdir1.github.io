<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-25T17:32:32+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ACM 重定向]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/25/acm-zhong-ding-xiang/"/>
    <updated>2014-07-25T09:07:06+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/25/acm-zhong-ding-xiang</id>
    <content type="html"><![CDATA[<h4>ACM输入输出重定向</h4>

<p>问题描述：<br/>
在做ACM题时，对于输入输出，总需要键盘来操作，这样显然不方向，对于多数据的测试，显然不合理，现有一个实用的重定向函数，可很好解决.</p>

<!--more-->


<h5>解决</h5>

<p>首先，gcc中有一个－D选项，这样表示在文件中添加宏定义</p>

<pre><code>gcc -o example example.c -D TAG
</code></pre>

<p>在正文中添加</p>

<pre><code>#ifndef TAG
    freopen("input.txt", "rt", stdin);
    freopen("output.txt", "wt+", stdout);
#endif
</code></pre>

<p>这样，就直接可以重定向到两个文件中．</p>

<p>包含在<code>#include&lt;stdio.h&gt;</code>中</p>

<hr />

<h5>另外</h5>

<p>在windows下找到一个解决方案，有bat文件中<code>example.exe&lt;input.txt&gt;output.txt</code> 不过，一般有IDE中就解决了，不必这么麻烦~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sudoku-solver]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/sudoku-solver/"/>
    <updated>2014-07-22T20:27:47+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/sudoku-solver</id>
    <content type="html"><![CDATA[<h4>Sudoku Solver</h4>

<p>Write a program to solve a Sudoku puzzle by filling the empty cells.</p>

<p>Empty cells are indicated by the character &lsquo;.&rsquo;.</p>

<p>You may assume that there will be only one unique solution.</p>

<!--more-->


<p>递归的方法，确实不错～　</p>

<h5>Code</h5>

<pre><code>bool isValid(vector&lt;vector&lt;char&gt; &gt; &amp;board, int a, int b) {
        int i,j;
        for(i = 0; i &lt; 9; i++)
            if(i != a &amp;&amp; board[i][b] == board[a][b])
                return false;

        for(j = 0; j &lt; 9; j++)
            if(j != b &amp;&amp; board[a][j] == board[a][b])
                return false;

        int x = a/3*3;
        int y = b/3*3;
        for(i = 0; i &lt; 3; i++)
            for(j = 0; j&lt; 3; j++)
                if(x+i != a &amp;&amp; y+j != b &amp;&amp; board[x+i][y+j] == board[a][b])
                    return false;
        return true;
    }
    bool solveSudokudfs(vector&lt;vector&lt;char&gt; &gt; &amp;board)
    {
        for(int i = 0; i &lt; 9; i++)
            for(int j = 0; j &lt; 9; j++)
            {
                if(board[i][j] == '.')
                {
                    for(int k = 1; k &lt;= 9; k++)
                    {
                        board[i][j] = '0' + k;
                        if(isValid(board,i,j) &amp;&amp; solveSudokudfs(board))
                            return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        return true;
    }
    void solveSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) {
        // Note: The Solution object is instantiated only once.
        solveSudokudfs(board);
    }
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid-sudoku]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/valid-sudoku/"/>
    <updated>2014-07-22T19:56:41+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/valid-sudoku</id>
    <content type="html"><![CDATA[<h4>Valid Sudoku</h4>

<p>The Sudoku board could be partially filled, where empty cells are filled with the character &lsquo;.&rsquo;.</p>

<p>A valid Sudoku board (partially filled) is not necessarily solvable. Only the filled cells need to be validated.</p>

<p>我这解法，绝对是对算法的侮辱～　哈哈</p>

<!--more-->


<p>Code:</p>

<pre><code>class Solution {
public:
    bool isValidSudoku(vector&lt;vector&lt;char&gt; &gt; &amp;board) 
    {
        for(int i=0;i&lt;9;i++)
        for(int j=0;j&lt;9;j++)
        {
            if(board[i][j]=='.')
                continue;
            for(int k=j+1;k&lt;9;k++)
                if(board[i][j]==board[i][k])return false;
            for(int k=i+1;k&lt;9;k++)
                if(board[i][j]==board[k][j])return false;
            if(i%3==0&amp;&amp;j%3==0)
            {
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
                if(board[i+2][j+1]!='.'&amp;&amp;board[i+2][j+1]==board[i][j])return false;
                if(board[i+1][j+2]!='.'&amp;&amp;board[i+1][j+2]==board[i][j])return false;
                if(board[i+2][j+2]!='.'&amp;&amp;board[i+2][j+2]==board[i][j])return false;
            }
            if(i%3==0&amp;&amp;(j-1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+2][j-1]!='.'&amp;&amp;board[i+2][j-1]==board[i][j])return false;
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
                if(board[i+2][j+1]!='.'&amp;&amp;board[i+2][j+1]==board[i][j])return false;   
            }
            if(i%3==0&amp;&amp;(j+1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+2][j-1]!='.'&amp;&amp;board[i+2][j-1]==board[i][j])return false;
                if(board[i+1][j-2]!='.'&amp;&amp;board[i+1][j-2]==board[i][j])return false;
                if(board[i+2][j-2]!='.'&amp;&amp;board[i+2][j-2]==board[i][j])return false;   
            }
            if((i-1)%3==0&amp;&amp;j%3==0)
            {
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
                if(board[i+1][j+2]!='.'&amp;&amp;board[i+1][j+2]==board[i][j])return false;
            }
            if((i-1)%3==0&amp;&amp;(j-1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+1][j+1]!='.'&amp;&amp;board[i+1][j+1]==board[i][j])return false;
            }
             if((i-1)%3==0&amp;&amp;(j+1)%3==0)
            {
                if(board[i+1][j-1]!='.'&amp;&amp;board[i+1][j-1]==board[i][j])return false;
                if(board[i+1][j-2]!='.'&amp;&amp;board[i+1][j-2]==board[i][j])return false;
            }

        }
        return true;
    }
};
</code></pre>

<p>好吧，管用就行，一遍过需要多仔细认真啊</p>

<p>这样代码还是很好看的，就是有点长</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode-combination Sum]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/22/leetcode-combination-sum/"/>
    <updated>2014-07-22T17:05:12+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/22/leetcode-combination-sum</id>
    <content type="html"><![CDATA[<h4>Combination Sum</h4>

<p>Given a set of candidate numbers &copy; and a target number (T), find all unique combinations in C where the candidate numbers sums to T.</p>

<p>The same repeated number may be chosen from C unlimited number of times.</p>

<p>Note:</p>

<p>All numbers (including target) will be positive integers.
Elements in a combination (a1, a2, … , ak) must be in non-descending order. (ie, a1 ≤ a2 ≤ … ≤ ak).</p>

<p>The solution set must not contain duplicate combinations.
For example, given candidate set 2,3,6,7 and target 7,
A solution set is:
```
[2,3,6,7] 7
[7]
[2, 2, 3]</p>

<p>```</p>

<!--more-->


<p>这题真是基础，之前一直对此类不知所措，现在略通一二，甚喜</p>

<p>Code:</p>

<pre><code>class Solution {
public:
    void Getcom(vector&lt;int&gt;&amp;can, int target, vector&lt;vector&lt;int&gt;&gt;&amp;result, int level, int &amp;sumcurrent, int nsize, vector&lt;int&gt;&amp;tmp)
    {
        if(sumcurrent&gt;target)return;
        if(target==sumcurrent)
        {
            result.push_back(tmp);
            return;
        }
        for(int i=level;i&lt;nsize;i++)
        {

                sumcurrent += can[i];
                tmp.push_back(can[i]);
                Getcom(can,target,result,i,sumcurrent,nsize,tmp);
                tmp.pop_back();
                sumcurrent -=can[i];
        }

    }
    vector&lt;vector&lt;int&gt; &gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) 
    {
       vector&lt;vector&lt;int&gt;&gt; result;
       vector&lt;int&gt;tmp;
       int size = candidates.size();
       sort(candidates.begin(),candidates.end());
       int sumc = 0;
       Getcom(candidates,target,result,0,sumc,size,tmp);
       return result;
    }
};
</code></pre>

<p>DFS方便记录结果，DP方便记数</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring/"/>
    <updated>2014-07-18T21:22:53+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/18/longest-palindromic-substring</id>
    <content type="html"><![CDATA[<h5><a href="https://oj.leetcode.com/problems/longest-palindromic-substring/">Longest Palindromic Substring</a></h5>

<h5>Probles</h5>

<p>Given a string S, find the longest palindromic substring in S. You may assume that the maximum length of S is 1000, and there exists one unique longest palindromic substring.</p>

<p>看本站内的总结：<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最长回文字符串</a></p>

<!--more-->


<h5>Code</h5>

<p>```
class Solution {
public:</p>

<pre><code>string longestPalindrome(string s)
{
    int len = s.length();
    string str="";
    if(len==0)return str;
    int maxlen = 0;
    int leng;
    int left,right;
    for(int i=0;i&lt;2*len-1;i++)
    {
        if(i%2==0)
        {
            leng = 1;
            left = i/2 - 1;
            right = i/2 + 1;
            while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s.at(left)==s.at(right))
            {
                leng += 2;
                left--;
                right++;
            }
             if(leng&gt;maxlen)
          {
                maxlen = leng;
                str = s.substr(i/2-maxlen/2, maxlen);
          }
        }
        else
        {
            leng = 0;
            left = i/2;
            right = i/2+1;
             while(left&gt;=0&amp;&amp;right&lt;len&amp;&amp;s[left]==s[right])
            {
                leng += 2;
                left--;
                right++;
            }


         if(leng&gt;maxlen)
          {
                maxlen = leng;
                str = s.substr(i/2-maxlen/2+1, maxlen);
          }
        }
    }
    return str;
}
</code></pre>

<p>};
```</p>

<h5>注意</h5>

<ul>
<li><ol>
<li>把奇偶统一起来，这样i的大小是2len-1的大小</li>
</ol>
</li>
<li><ol>
<li>还有一个注意点是，substr()这个两个参数是指起始和长度，起始从0开始就算第一个</li>
</ol>
</li>
<li><ol>
<li>后面两个if判断不能统一起来，因为substr中的参数不一样</li>
</ol>
</li>
<li><ol>
<li>方法：<strong>从中间向两边比较来判断是否回文，例a_b_c_b_a，则这个字符串abcba长度5，判断的位置有9个，然后从中间向两边展开，首先判断是否出界，再看是不是相等，这样最后更新长度和字符串</strong></li>
</ol>
</li>
<li>5.　本文属于<a href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/">最系列</a>的应用</li>
</ul>

]]></content>
  </entry>
  
</feed>
