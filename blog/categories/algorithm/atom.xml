<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-07-14T22:14:20+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[最系列]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie/"/>
    <updated>2014-07-13T19:58:08+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/13/zui-xi-lie</id>
    <content type="html"><![CDATA[<h4>最系列</h4>

<p>常见到最长子序列，最长公共子序列等，网上总结了也很多．但自己实现一次方才了解．发现收获很多的．</p>

<h4>目录</h4>

<ul>
<li>1.<a href="#1">最长公共子序列</a></li>
<li>2.<a href="#2">最长公共子串</a></li>
<li>3.<a href="#3">最长重复子串</a></li>
<li>4.<a href="#4">最长回文子串</a></li>
<li>5.<a href="#5">最大递增子序列</a></li>
<li>6.<a href="#6">最大子数组和</a></li>
<li>7.<a href="#7">最大M子段和</a></li>
<li>8.<a href="#8">最大和子矩阵</a></li>
<li>9.<a href="#9">字符串编码距离</a></li>
<li>10.<a href="#10">最长不重复子串</a></li>
</ul>


<!--more-->




<h5 id="1">最长公开子序列</h5>


<p>这个最基础，动态规划；转移方程:</p>

<p>C[i,j] = 0; 初始</p>

<p>C[i,j] = C[i-1,j-1] + 1; Xi = Yi</p>

<p>C[i,j] = max(C[i-1,j], C[i,j-1]); Xi != Yi;</p>

<p>**代码</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int LCS(char *str1, char *str2, int m, int n, int len[][100],int sub[][100])
{
        int i,j;
        for(i=0;i&lt;m;i++)
            len[i][0] = 0;
        for(i=0;i&lt;n;i++)
            len[0][i] = 0;
        for(i=1;i&lt;=m;i++)
        for(j=1;j&lt;=n;j++)
        {
            if(str1[i-1]==str2[j-1])
            {
                len[i][j] = len[i-1][j-1] + 1;
                sub[i][j] = 0;
            }
            else if(len[i-1][j]&gt;=len[i][j-1])
            {
                len[i][j] = len[i-1][j];
                sub[i][j] = 1;
            }
            else
            {
                len[i][j] = len[i][j-1];
                sub[i][j] = -1;
            }
        }
        return len[m][n];
}

void PrintSub(char *x,int i, int j, int b[][100])
{
    if(i==0||j==0)
        return;
    if(b[i][j] == 0)
    {
        PrintSub(x,i-1,j-1,b);
        printf("%c",x[i-1]);
    }
    else if(b[i][j]==1)
        PrintSub(x,i-1,j,b);
    else 
        PrintSub(x,i,j-1,b);
    return ;
}
int main()
{
    char str1[100],str2[100];
    int len1,len2;
    int subq[100][100],subq_len[100][100]; 
    while(~scanf("%s %s",str1,str2))
    {
        len1 = strlen(str1); 
        len2 = strlen(str2); 
        int len = LCS(str1,str2,len1,len2,subq_len,subq);
        printf("%d\n",len);
        PrintSub(str1,len1,len2,subq);
        printf("\n");
    }
    return 0;
}
</code></pre>

<h5 id="2">最长公开子串</h5>


<p>串和序列的区别在于连续与否，两者实现也差不多</p>

<p>**代码</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int LCS(char *str1, char *str2, int m, int n, char *str3, int len[][100])
{
        int i,j;
        int max = -1;
        int x,y;
        int k;
        for(i=0;i&lt;m;i++)
            len[i][0] = 0;
        for(i=0;i&lt;n;i++)
            len[0][i] = 0;
        for(i=1;i&lt;=m;i++)
        for(j=1;j&lt;=n;j++)
        {
            if(str1[i-1]==str2[j-1])
                len[i][j] = len[i-1][j-1] + 1;
            else 
                len[i][j] = 0;
            if(len[i][j]&gt;max)
            {
                max = len[i][j];
                x = i;
                y = j;
            }
        }
        k = max;
        str3[k] = '\0';
        while(k&gt;=0)
            str3[--k] = str1[--x];
        return max;
}

int main()
{
    char str1[100],str2[100];
    char str3[100];
    int len1,len2;
    int subq_len[100][100]; 
    while(~scanf("%s %s",str1,str2))
    {
        len1 = strlen(str1); 
        len2 = strlen(str2); 
        int len = LCS(str1,str2,len1,len2,str3,subq_len);
        printf("%s\n",str3);
        printf("%d\n",len);
    }
    return 0;
}
</code></pre>

<h5 id="6">最大子数组和</h5>


<p>即一个数组中连续元素和的最大值，如1,2,-4,2 最大是3</p>

<p>**代码:　</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

int main()
{
    int n, a[100];
    int i,sum,tmp;
    int maxsum ;
    while(~scanf("%d",&amp;n))
    {
        maxsum = INT_MIN;
        sum = tmp = 0;
        for(i=0;i&lt;n;i++)
        {
            scanf("%d",&amp;a[i]);
            tmp += a[i];
            if(tmp&lt;0)
                tmp = 0;
            else
                sum = tmp;
            if(sum&gt;maxsum)
                maxsum = sum;
        }
        if(maxsum&lt;=0)
        {
            maxsum = a[0];
            for(i=0;i&lt;n;i++)
                if(a[i]&gt;maxsum)
                    maxsum = a[i];
        }
        printf("%d\n",maxsum);
    }
    return 0;
}
</code></pre>

<h5 id="5">最大子数组</h5>


<p>序列可以为数组，也可以为特别的结构体，原理应该是一样的
**代码：</p>

<pre><code>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
//return the length
int LongIncreaseSubsquence1(int *a, int n, int *b)
{
    int i,j;
    int lenght = 1;
    if(n&lt;=0)return 0;
    if(n==1)return 1;
    b[0] = 1;
    for(i=1;i&lt;n;i++)
    {
        b[i] = 1;
        for(j=0;j&lt;i;j++)
        {
            if(a[j]&lt;a[i]&amp;&amp;b[j]+1&gt;b[i])
               b[i] = b[j] + 1;
        }
    }
    for(i=1;i&lt;n;i++)
        lenght = (lenght&gt;=b[i]?lenght:b[i]);
    return lenght;
}
int main()
{
    int a[100];
    int b[100];
    int n,i;
    while(~scanf("%d",&amp;n))
    {
        for(i=0;i&lt;n;i++)
            scanf("%d",&amp;a[i]);
        int len = LongIncreaseSubsquence1(a,n,b);
        printf("%d\n",len);
    }
    return 0;
}
</code></pre>

<p>还有两种方法：
&ndash; 1.基于最长公共子序列，先把原串排序，再求最长公共子序列
&ndash; 2.再查找b[n]的时候，用二分法，因为b[n]是递增的序列</p>

<hr />

<h5>最大各子矩阵</h5>

<h5>最长重复子串</h5>

<h5>最长回文子串</h5>

<h5>最大M子段</h5>

<h5 id="9">字符编码距离</h5>


<p>两个字符串，从其中一个变为另外一个需要的操作次数就是编码距离，这个或者还有其它的名词称谓．</p>

<p>操作只有三种最基本的，即增删改，例如abc和bcd的距离就是，abc删除a，再后面添加d，操作就两步</p>

<p>这种有一个很简单的方法，基于最长公共子序列，首先求出最长公共子序列int len = GetLongestCommomSubsquence(str1,str2),然后得到两个字符串长度，len1,len2.则操作的距离是len1+len2-len*2</p>

<p>当这几个系列的操作都了解后，好多字符串的处理都是基于此的</p>

<hr />

<p><strong><em>待续</em></strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Love-Letter Mystery]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/11/the-love-letter-mystery/"/>
    <updated>2014-07-11T14:55:48+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/11/the-love-letter-mystery</id>
    <content type="html"><![CDATA[<h4><a href="https://www.hackerrank.com/challenges/the-love-letter-mystery">The Love-Letter Mystery</a></h4>

<hr />

<p>James got hold of a love letter that his friend Harry has written for his girlfriend. Being the prankster that James is, he decides to meddle with it. He changes all the words in the letter into palindromes.</p>

<p>While modifying the letters of the word, he follows 2 rules:</p>

<p>(a) He always reduces the value of a letter, e.g. he changes &rsquo;d' to &lsquo;c&rsquo;, but he does not change &lsquo;c&rsquo; to &rsquo;d'.
(b) If he has to repeatedly reduce the value of a letter, he can do it until the letter becomes &lsquo;a&rsquo;. Once a letter has been changed to &lsquo;a&rsquo;, it can no longer be changed.</p>

<p>Each reduction in the value of any letter is counted as a single operation. Find the minimum number of operations he carries out to convert a given string into a palindrome.</p>

<!--more-->


<p>Input Format</p>

<p>The first line contains an integer T, i.e., the number of test cases.
The next T lines will contain a string each.</p>

<p>Output Format</p>

<p>A single line containing the number of minimum operations corresponding to each test case.</p>

<p>Constraints
<code>
1 ≤ T ≤ 10
1 ≤ length of string ≤ 104
All characters are lower cased english letters.
</code>
Sample Input #00
<code>
3
abc
abcba
abcd
</code>
Sample Output #00
<code>
2
0
4
</code>
Explanation</p>

<p>For the first test case, ab<em>c</em> &ndash;> ab<em>b</em> &ndash;> ab<em>a</em>.
For the second test case, abcba is a palindromic string.
For the third test case, abc<em>d</em> &ndash;> abc<em>c</em> &ndash;> abc<em>b</em> &ndash;> abc<em>a</em> = ab<em>c</em>a &ndash;> ab<em>b</em>a.</p>

<hr />

<p>**The Code:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

int main()
{
    int T,sum,j,diff;
    char str[10000];
    while(cin&gt;&gt;T)
        {
        for(int i=0;i&lt;T;i++)
            {
            cin&gt;&gt;str;
            int len = strlen(str);
            len -=1;
            sum = 0;
            j = 0;
            while(j&lt;len)
                {
                str[j]&gt;str[len]?diff=str[j]-str[len]:diff=str[len]-str[j];
                sum += diff;
                j++;
                len--;
            }
            cout&lt;&lt;sum&lt;&lt;endl;
        }
    }
    return 0;
}
</code></pre>

<p><audio controls="controls">
  <source src="http://mkdir1.github.io/music/xing.mp3" type="audio/mpeg">
</audio></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gem-stones]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/11/gem-stones/"/>
    <updated>2014-07-11T14:38:44+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/11/gem-stones</id>
    <content type="html"><![CDATA[<h3><a href="https://www.hackerrank.com/challenges/gem-stones">Gem-stones</a></h3>

<p>John has discovered various rocks. Each rock is composed of various elements, and each element is represented by a lowercase latin letter from &lsquo;a&rsquo; to &lsquo;z&rsquo;. An element can be present multiple times in a rock. An element is called a &lsquo;gem-element&rsquo; if it occurs at least once in each of the rocks.</p>

<p>Given the list of rocks with their compositions, display the number of gem-elements that exist in those rocks.</p>

<!--more-->


<ul>
<li>Input Format</li>
</ul>


<p>The first line consists of N, the number of rocks.
Each of the next N lines contain rocks' composition. Each composition consists of lowercase letters of English alphabet.</p>

<ul>
<li>Output Format</li>
</ul>


<p>Print the number gem-elements that exist in those rocks.</p>

<p>Constraints
<code>
1 ≤ N ≤ 100
Each composition consists of only small latin letters ('a'-'z').
1 ≤ Length of each composition ≤ 100
</code>
Sample Input</p>

<p><code>
3
abcdde
baccd
eeabg
</code>
Sample Output</p>

<p><code>
2
</code>
Explanation
Only &ldquo;a&rdquo;, &ldquo;b&rdquo; are the two kind of gem-elements, since these are the only characters that occur in each of the rocks' composition.</p>

<hr />

<p><strong>The Code</strong>:</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

int main()
{
    int N;
    int ele[26];
    char str[100];
    while(cin&gt;&gt;N)
    {
        int sum = 0;
        for(int i=0;i&lt;26;i++)ele[i]=1;
        for(int i=0;i&lt;N;i++)
        {
            cin&gt;&gt;str;
            int len = strlen(str);
            for(int j=0;j&lt;len;j++)
                if(ele[str[j]-'a']!=0)
                ele[str[j]-'a']++;
            for(int k=0;k&lt;26;k++)
            {        
                if(ele[k]&gt;1)
                    ele[k]=1;
                else
                    ele[k]=0;
            } 
        } 
        for(int j=0;j&lt;26;j++)
                if(ele[j]==1)sum++;

           printf("%d\n",sum);
        }

    return 0;    
}

---
</code></pre>
]]></content>
  </entry>
  
</feed>
