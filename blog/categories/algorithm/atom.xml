<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Algorithm | Vintion's blog]]></title>
  <link href="http://mkdir1.github.io/blog/categories/algorithm/atom.xml" rel="self"/>
  <link href="http://mkdir1.github.io/"/>
  <updated>2014-08-29T16:17:42+08:00</updated>
  <id>http://mkdir1.github.io/</id>
  <author>
    <name><![CDATA[Vintion]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Poj试题分类]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/29/pojshi-ti-fen-lei/"/>
    <updated>2014-08-29T15:29:08+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/29/pojshi-ti-fen-lei</id>
    <content type="html"><![CDATA[<h4>POJ试题分类</h4>

<!--more-->


<p>初期:</p>

<p>一.基本算法:</p>

<pre><code> (1)枚举. (poj1753,poj2965)

 (2)贪心(poj1328,poj2109,poj2586)

 (3)递归和分治法.

 (4)递推.

 (5)构造法.(poj3295)

 (6)模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)
</code></pre>

<p>二.图算法:</p>

<pre><code> (1)图的深度优先遍历和广度优先遍历.

 (2)最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra)
    (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)

 (3)最小生成树算法(prim,kruskal)
    (poj1789,poj2485,poj1258,poj3026)

 (4)拓扑排序 (poj1094)

 (5)二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)

 (6)最大流的增广路算法(KM算法). (poj1459,poj3436)
</code></pre>

<p>三.数据结构.</p>

<pre><code> (1)串 (poj1035,poj3080,poj1936)

 (2)排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)

 (3)简单并查集的应用.

 (4)哈希表和二分查找等高效查找法(数的Hash,串的Hash)  
    (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)

 (5)哈夫曼树(poj3253)

 (6)堆

 (7)trie树(静态建树、动态建树) (poj2513)
</code></pre>

<p>四.简单搜索</p>

<pre><code> (1)深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)

 (2)广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)

 (3)简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)
</code></pre>

<p>五.动态规划</p>

<pre><code> (1)背包问题. (poj1837,poj1276)

 (2)型如下表的简单DP(可参考lrj的书 page149):

   1.E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533)

   2.E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列)   
     (poj3176,poj1080,poj1159)

   3.C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)
</code></pre>

<p>六.数学</p>

<pre><code> (1)组合数学:

    1.加法原理和乘法原理.

    2.排列组合.

    3.递推关系.

      (POJ3252,poj1850,poj1019,poj1942)

 (2)数论.

    1.素数与整除问题

    2.进制位.

    3.同余模运算.

      (poj2635, poj3292,poj1845,poj2115)

 (3)计算方法.

    1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)
</code></pre>

<p>七.计算几何学.</p>

<pre><code> (1)几何公式.

 (2)叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)

 (3)多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交)

     (poj1408,poj1584)

 (4)凸包. (poj2187,poj1113)
</code></pre>

<p>中级:
一.基本算法:</p>

<pre><code> (1)C++的标准模版库的应用. (poj3096,poj3007)
 (2)较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)
</code></pre>

<p>二.图算法:</p>

<pre><code> (1)差分约束系统的建立和求解. (poj1201,poj2983)
 (2)最小费用最大流(poj2516,poj2516,poj2195)
 (3)双连通分量(poj2942)
 (4)强连通分支及其缩点.(poj2186)
 (5)图的割边和割点(poj3352)
 (6)最小割模型、网络流规约(poj3308, )
</code></pre>

<p>三.数据结构.</p>

<pre><code> (1)线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)
 (2)静态二叉检索树. (poj2482,poj2352)
 (3)树状树组(poj1195,poj3321)
 (4)RMQ. (poj3264,poj3368)
 (5)并查集的高级应用. (poj1703,2492)
 (6)KMP算法. (poj1961,poj2406)
</code></pre>

<p>四.搜索</p>

<pre><code> (1)最优化剪枝和可行性剪枝
 (2)搜索的技巧和优化 (poj3411,poj1724)
 (3)记忆化搜索(poj3373,poj1691)
</code></pre>

<p>五.动态规划</p>

<pre><code> (1)较为复杂的动态规划(如动态规划解特别的施行商问题等)
     (poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)
 (2)记录状态的动态规划. (POJ3254,poj2411,poj1185)
 (3)树型动态规划(poj2057,poj1947,poj2486,poj3140)
</code></pre>

<p>六.数学</p>

<pre><code> (1)组合数学:
    1.容斥原理.
    2.抽屉原理.
    3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026).
    4.递推关系和母函数.

 (2)数学.
    1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222)
    2.概率问题. (poj3071,poj3440)
    3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)
 (3)计算方法.
    1.0/1分数规划. (poj2976)
    2.三分法求解单峰(单谷)的极值.
    3.矩阵法(poj3150,poj3422,poj3070)
    4.迭代逼近(poj3301)
 (4)随机化算法(poj3318,poj2454)
 (5)杂题.
     (poj1870,poj3296,poj3286,poj1095)
</code></pre>

<p>七.计算几何学.</p>

<pre><code>    (1)坐标离散化.
    (2)扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用).
        (poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)
    (3)多边形的内核(半平面交)(poj3130,poj3335)
    (4)几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)
</code></pre>

<p>高级:
一.基本算法要求:</p>

<pre><code>  (1)代码快速写成,精简但不失风格 
      (poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)
  (2)保证正确性和高效性. poj3434
</code></pre>

<p>二.图算法:</p>

<pre><code>  (1)度限制最小生成树和第K最短路. (poj1639)
  (2)最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解)
     (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446
  (3)最优比率生成树. (poj2728)
  (4)最小树形图(poj3164)
  (5)次小生成树.
  (6)无向图、有向图的最小环  
</code></pre>

<p>三.数据结构.</p>

<pre><code>  (1)trie图的建立和应用. (poj2778)
  (2)LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法
      (RMQ+dfs)).(poj1330)
  (3)双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的
      目的). (poj2823)
  (4)左偏树(可合并堆). 
  (5)后缀树(非常有用的数据结构,也是赛区考题的热点).
     (poj3415,poj3294)
</code></pre>

<p>四.搜索</p>

<pre><code>  (1)较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)
  (2)广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)
  (3)深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286)
</code></pre>

<p>五.动态规划</p>

<pre><code>  (1)需要用数据结构优化的动态规划.
     (poj2754,poj3378,poj3017)
  (2)四边形不等式理论.
  (3)较难的状态DP(poj3133)
</code></pre>

<p>六.数学</p>

<pre><code>  (1)组合数学.
    1.MoBius反演(poj2888,poj2154)
    2.偏序关系理论.
  (2)博奕论.
    1.极大极小过程(poj3317,poj1085)
    2.Nim问题.
</code></pre>

<p>七.计算几何学.</p>

<pre><code>  (1)半平面求交(poj3384,poj2540)
  (2)可视图的建立(poj2966)
  (3)点集最小圆覆盖.
  (4)对踵点(poj2079)
  八.综合题.
  (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最小绝对值]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/22/zui-xiao-jue-dui-zhi/"/>
    <updated>2014-08-22T21:31:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/22/zui-xiao-jue-dui-zhi</id>
    <content type="html"><![CDATA[<h4>求一个递增序列中绝对值最小的数</h4>

<p>比如(-3, -1, 2,4,6),返回-1</p>

<p>当然，时间小于O(n)</p>

<!--more-->


<p>```</p>

<h1>include&lt;stdio.h></h1>

<h1>define ABS(x,y) ((-x)>=(y)?(y):(x))</h1>

<p>int GetAbsMin(int *a, int n)
{</p>

<pre><code>if(a[0]&gt;=0)return a[0];
if(a[n-1]&lt;=0)return a[n-1];
int begin = 0;
int end   = n-1;

int left = a[0];
int right = a[n-1];
int mid;
while(begin&lt;=end)
{
    mid = (begin+end)/2;
    if(a[mid]==0)return 0;
    if(a[mid]&gt;0)
    {
        if(a[mid-1]&lt;0)
        {
            left = a[mid-1];
            right = a[mid];
            break;
        }
        else
        {
            end = mid-1;
        }
    }
    else
    {
        if(a[mid+1]&gt;0)
        {
            left=a[mid];
            right=a[mid+1];
            break;
        }
        else
            begin = mid + 1;
    }

}
return ABS(left,right);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>int n,i;
int a[100];
int result;
while(~scanf("%d",&amp;n))
{
    for(i=0;i&lt;n;i++)
        scanf("%d",&amp;a[i]);
   result =  GetAbsMin(a,n); 
   printf("%d\n",result);
}
return 0;
</code></pre>

<p>}</p>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进制转化]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/18/jin-zhi-zhuan-hua/"/>
    <updated>2014-08-18T17:35:10+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/18/jin-zhi-zhuan-hua</id>
    <content type="html"><![CDATA[<h4>进制转化</h4>

<p>改进了一下进制转化的代码，每次都有进步</p>

<!--more-->


<h5>Code</h5>

<p>```</p>

<h1>include&lt;stdio.h></h1>

<h1>include&lt;string.h></h1>

<p>char result[1000];
static int Name[36]={&lsquo;0&rsquo;,&lsquo;1&rsquo;,&lsquo;2&rsquo;,&lsquo;3&rsquo;,&lsquo;4&rsquo;,&lsquo;5&rsquo;,&lsquo;6&rsquo;,&lsquo;7&rsquo;,&lsquo;8&rsquo;,&lsquo;9&rsquo;,&lsquo;A&rsquo;,&lsquo;B&rsquo;,&lsquo;C&rsquo;,&rsquo;D',&lsquo;E&rsquo;,&lsquo;F&rsquo;,&lsquo;G&rsquo;,&lsquo;H&rsquo;,&lsquo;I&rsquo;,&lsquo;J&rsquo;,&lsquo;K&rsquo;,&lsquo;L&rsquo;,&rsquo;M',&lsquo;N&rsquo;,&lsquo;O&rsquo;,&lsquo;P&rsquo;,&lsquo;Q&rsquo;,&lsquo;R&rsquo;,&rsquo;S',&rsquo;T',&lsquo;U&rsquo;,&lsquo;V&rsquo;,&lsquo;W&rsquo;,&lsquo;X&rsquo;,&lsquo;Y&rsquo;,&lsquo;Z&rsquo;};</p>

<p>void reverse(char *p)
{</p>

<pre><code>int len = strlen(p);
int i = 0;
int j = len-1;
char ch;
while(i&lt;j)
{
    ch = p[i];
    p[i] = p[j];
    p[j] = ch;
    i++;
    j--;
}
return;
</code></pre>

<p>}
void conver(int n, int m)<br/>
{</p>

<pre><code>int signal = 0;
int i = 0;
if(n&lt;0)
{
    n = -n;
    signal = -1;
    i= 1;
}
while(n/m!=0)
{
    result[i++] = Name[n%m];
    n = n/m;
}
result[i] = Name[n];
result[i+1] = 0;
if(signal==-1)
{
    result[0] = '-';
    reverse(result+1);
}
else
    reverse(result);
printf("%s\n",result);
</code></pre>

<p>}</p>

<p>int main()
{</p>

<pre><code>int n,m;
while(~scanf("%d %d",&amp;n,&amp;m))
    conver(n,m);
return 0;
</code></pre>

<p>}
```
将十进制n转化成m进制的字符串输出
这里还可以进一步的是，将十进制的字符串
void conver(char *n, int m)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Itoa]]></title>
    <link href="http://mkdir1.github.io/blog/2014/08/12/itoa/"/>
    <updated>2014-08-12T16:05:35+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/08/12/itoa</id>
    <content type="html"><![CDATA[<h4>ITOA</h4>

<p>一个很实现十进制整数转变成任意2-16进制字符串的代码，写得短小精练，原作者确实厉害，叹服</p>

<!--more-->


<h5>code</h5>

<p>```</p>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;string.h></h1>

<p>char *my_itoa(int value, int radix) {</p>

<pre><code>static char buf[32] = {0};
int i = 30;
for(;value&amp;&amp;(i&gt;=0);--i,value/=radix) {
    buf[i] = "0123456789abcdef"[value%radix];
}
return &amp;buf[i+1];
</code></pre>

<p>}
int main()
{</p>

<pre><code>int val, radix;
while(~scanf("%d %d",&amp;val,&amp;radix))
    printf("%s\n",my_itoa(val,radix));
return 0;
</code></pre>

<p>}
```</p>

<p>仔细体会一下，　enjoy coding&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Leetcode-copy List With Random Pointer]]></title>
    <link href="http://mkdir1.github.io/blog/2014/07/28/leetcode-copy-list-with-random-pointer/"/>
    <updated>2014-07-28T00:53:19+08:00</updated>
    <id>http://mkdir1.github.io/blog/2014/07/28/leetcode-copy-list-with-random-pointer</id>
    <content type="html"><![CDATA[<h4>Copy List with random pointer</h4>

<p>这题早就看过，解法也知道，但是，想法与代码差距很大，半天都没发现错误．还得多多练习</p>

<!--more-->


<h5>Problem</h5>

<p>A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.</p>

<p>Return a deep copy of the list.</p>

<h5>code:</h5>

<p>``` c++
/<em><em>
 * Definition for singly-linked list with a random pointer.
 * struct RandomListNode {
 *     int label;
 *     RandomListNode </em>next, </em>random;
 *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}
 * };
 */
class Solution {
public:</p>

<pre><code>RandomListNode *copyRandomList(RandomListNode *head) 
{
    RandomListNode *Head = head;
    if(NULL==head)
        return NULL;
    RandomListNode *p,*q;
    p = head;
    while(NULL!=p)
    {
        q = new RandomListNode(p-&gt;label);
        q-&gt;next = p-&gt;next;
        p-&gt;next = q;
        p = q-&gt;next;
    }
    p = head;
    while(NULL!=p)
    {
        if(p-&gt;random!=NULL) //　这里可能为空
            p-&gt;next-&gt;random = p-&gt;random-&gt;next;
        else
            p-&gt;next-&gt;random = NULL;
         p = p-&gt;next-&gt;next;
    }
    Head = head-&gt;next;
    p = head;
    q = Head;
    if(NULL==q-&gt;next)
    {
        p-&gt;next = NULL;
        return Head;
    }
    while(NULL!=q-&gt;next)
    {
        p-&gt;next =  q-&gt;next;
        p = p-&gt;next;
        q-&gt;next = p-&gt;next;
        q = q-&gt;next;
    }
   p-&gt;next = NULL;// 这里要断开
    return Head;
}
</code></pre>

<p>};
```</p>

<p>两处注释的地方，瞪大眼睛都没看出来．</p>
]]></content>
  </entry>
  
</feed>
